This is a work-in-progress [website](https://fanwangecon.github.io/CodeDynaAsset/) of collections of code for solving several infinite horizon exogenous incomplete dynamic asset models, produced by [Fan](https://fanwangecon.github.io/). Materials gathered from various [papers](https://fanwangecon.github.io/research) on financial access with fixed costs, discrete and continuous asset choice grids and other features. Please contact [FanWangEcon](https://fanwangecon.github.io/) for issues or problems.

Generally, looped, vectorized, and efficient-vectorized versions of the same code from Matlab (tested with [Matlab 2019a](https://www.mathworks.com/company/newsroom/mathworks-announces-release-2019a-of-matlab-and-simulink.html)) are shown. Looped codes are shown for clarity, vectorized codes are shown for speed. Each function is written with default parameters and is directly callable: 1, clone the project via github, see [here](docs/gitsetup.md); 2, add project to path; 3, click run any file. Algorithms are language agnostic. Speed difference across languages is not significant when solving models using vectorized grid-based solution algorithms. For functions, files included:

1. **m**: matlab m file, each callable with the whole repository cloned
2. **publish html**: html files generated by pressing the publish button in matlab, includes m file code with mark-ups, and also includes tabular and graphical outputs from benchmark simulation
3. **profile**: html files generated by profiling the m file, shows timing.


# 1. The One Asset One Shock Problem (AZ)
<!-- https://fanwangecon.github.io/CodeDynaAsset/m_az -->

The standard model with an asset and one shock. Exogenous incomplete borrowing and savings. Wage shocks follow AR1.

## 1.1 Main Optimization Solution Files (AZ)

Solving as benchmark with these [parameters](https://fanwangecon.github.io/CodeDynaAsset/m_az/paramfunc/html/ffs_az_set_default_param.html), in particular:

- savings only problem
- **750** grid points for asset states/choices
- **15** grid points for the AR1 shock

Using three algorithm that provide identical solutions:

1. *az* model [looped solution](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_vf.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/solve/ff_az_vf.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_vf.html) \| [**profile**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/profile/ff_az_vf_default_p3/file0.html)
    * speed: 9765.7 seconds (5.5 Hours)
    * loops: 1 for VFI, 1 for shocks, 1 for endo state, 1 for choice, 1 for future shocks
2. *az* model [vectorized solution](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_vf_vec.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/solve/ff_az_vf_vec.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_vf_vec.html) \| [**profile**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/profile/ff_az_vf_vec_default_p3/file0.html)    
    * speed: 34.3 seconds
    * loops: 1 for VFI, 1 for shocks, vectorize remaining 3 loops
3. *az* model [optimized vectorized solution](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_vf_vecsv.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/solve/ff_az_vf_vecsv.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_vf_vecsv.html) \| [**profile**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/profile/ff_az_vf_vecsv_default_p3/file0.html)    
    * speed: 1.2 seconds
    * loops: 1 for VFI, 1 for shocks, vectorize remaining 3 loops
    * store u(c) in cells, several speed improvements described [here](https://fanwangecon.github.io/M4Econ/)

## 1.2 Asset Distributions (AZ)

Solving for the asset distribution.

## 1.3 Solution Support Files (AZ)

**Parameters and Function Definitions**:
1. *az* model [set default parameters](https://fanwangecon.github.io/CodeDynaAsset/m_az/paramfunc/html/ffs_az_set_default_param.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/paramfunc/ffs_az_set_default_param.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/paramfunc/html/ffs_az_set_default_param.html)
    * param_map: container map for carrying parameters across functions
    * support_map: container map for carrying programming instructions etc across functions
2. *az* model [set functions](https://fanwangecon.github.io/CodeDynaAsset/m_az/paramfunc/html/ffs_az_set_functions.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/paramfunc/ffs_az_set_functions.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/paramfunc/html/ffs_az_set_functions.html)
    * functions: centrally define functions as function handles
3. *az* model [generate states, choices, and shocks grids](https://fanwangecon.github.io/CodeDynaAsset/m_az/paramfunc/html/ffs_az_get_funcgrid.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/paramfunc/ffs_az_get_funcgrid.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/paramfunc/html/ffs_az_get_funcgrid.html)
    * func_map: container map containing all function handles
    * armt_map: container map containing matrixes for states and choices.

**Output Analysis**:
1.  *az* model [solution results processing](https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_vf_post.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/solvepost/ff_az_vf_post.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_vf_post.html)
    * table: value and policy function by states and shocks
    * table: iteration convergence and percentage policy function change by shock
    * graph: value + policy functions with levels, logged levels and percentages
    * mat: store all workspace matrixes, arrays, scalar values to matrixes
2. *az* model [solution results graphing](https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_vf_post_graph.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_az/solvepost/ff_az_vf_post_graph.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_vf_post_graph.html)
    * graph: value function by asset and shock
    * graph: consumption and asset choice levels
    * graph: consumption and asset logged levels
    * graph: consumption and asset as percentages of coh and assets


## 1.4 Cash-on-hand and One Shock (COH-Z)

The problem could be posed slightly differently with the asset state variable as cash-on-hand. The codes are basically identical, and are shown here in this [folder](https://fanwangecon.github.io/CodeDynaAsset/m_oz). The files are almost identical to the earlier files, they are included here for completeness. Speeds are the same.

**Main Optimization Solution Files**:
- *coh-z* model [looped solution](https://fanwangecon.github.io/CodeDynaAsset/m_oz/solve/html/ff_oz_vf.html), [vectorized solution](https://fanwangecon.github.io/CodeDynaAsset/m_oz/solve/html/ff_oz_vf_vec.html), [optimized vectorized solution](https://fanwangecon.github.io/CodeDynaAsset/m_oz/solve/html/ff_oz_vf_vecsv.html)

**Parameters and Function Definitions**:
- *coh-z* model [set default parameters](https://fanwangecon.github.io/CodeDynaAsset/m_oz/paramfunc/html/ffs_oz_set_default_param.html), [set functions](https://fanwangecon.github.io/CodeDynaAsset/m_oz/paramfunc/html/ffs_oz_set_functions.html), [generate states, choices, and shocks grids](https://fanwangecon.github.io/CodeDynaAsset/m_oz/paramfunc/html/ffs_oz_get_funcgrid.html)

**Output Analysis**:
- *coh-z* model [solution results processing](https://fanwangecon.github.io/CodeDynaAsset/m_oz/solvepost/html/ff_oz_vf_post.html), [solution results graphing](https://fanwangecon.github.io/CodeDynaAsset/m_oz/solvepost/html/ff_oz_vf_post_graph.html)


# 2. The Risky + Safe Asset Problem (AKZ)

Two endogenous assets, one safe one risky. Risky asset could be stock with constant return to scale, or physical capital investment with depreciation and decreasing return to scale. Note that the utility function is CRRA, however, households do not have constant share of risky investment for any wealth (cash-on-hand) levels when risky asset has decreasing return to scale and when shock is highly persistent.

There are more analytical ways of solving the basic version of this problem. Here we stick to using this grid based solution algorithm which allows for flexibly solving non-differentiable and non-continuous problems. The grid based solution algorithm now with 2 endogenous choices and states requires exponentially more computation time than the ak model. Here I provide three solution algorithms that parallel the three provided for the *az* model earlier. In this section, I explicitly solve for the two asset choices jointly. In section 3, I significantly increase the accuracy of the solution by solving the problem in two stages at very high speed.

## 2.1 Main Optimization Solution Files (AKZ)

Solving as benchmark with these [parameters](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_set_default_param.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/paramfunc/ffs_akz_set_default_param.m), in particular:

- savings problem with alternative safe and risky asset
- **45** aggregate savings grid points, **1035** combinations of safe and risky asset choices. Choice grids shown [here](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html) at the end of the file.
- **15** grid points for the AR1 shock

Note for the *az* model we had 750 grid points for the a choice. Now we are significantly reducing that to accommodate the additional risky capital choice.

1. *akz* model [looped solution](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_vf.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/solve/ff_akz_vf.m) \|
    * speed: with 1035 grid points for safe and risky asset, using loop in matlab, this program takes many hours to execute.
    * loops: 1 for VFI, 1 for shocks, 1 for coh, 1 for a and k choices, 1 for future shocks
2. *akz* model [vectorized solution](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_vf_vec.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/solve/ff_akz_vf_vec.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_vf_vec.html) \| [**profile**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/profile/ff_akz_vf_vec_default_p3/file0.html)    
    * speed: 71.5 seconds
    * loops: 1 for VFI, 1 for shocks, vectorize remaining
3. *akz* model [optimized vectorized solution](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_vf_vecsv.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/solve/ff_akz_vf_vecsv.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_vf_vecsv.html) \| [**profile**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/profile/ff_akz_vf_vecsv_default_p3/file0.html)    
    * speed: 2.1 seconds
    * loops: 1 for VFI, 1 for shocks, vectorize remaining
    * store u(c) in cells, several speed improvements described [here](https://fanwangecon.github.io/M4Econ/)

## 2.2 Asset Distributions (AKZ)

Solving for the asset distribution.

## 2.3 Solution Support Files (AKZ)

**Parameters and Function Definitions**:
1. *akz* model [set default parameters](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_set_default_param.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/paramfunc/ffs_akz_set_default_param.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_set_default_param.html)
    * param_map: container map for carrying parameters across functions
    * support_map: container map for carrying programming instructions etc across functions
2. *akz* model [set functions](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_set_functions.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/paramfunc/ffs_akz_set_functions.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_set_functions.html)
    * functions: centrally define functions as function handles
3. *akz* model [generate states, choices, and shocks grids](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/paramfunc/ffs_akz_get_funcgrid.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html)
    * func_map: container map containing function handles
    * armt_map: container map containing matrixes for states and choices.

**Output Analysis**:
1.  *akz* model [solution results processing](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solvepost/html/ff_akz_vf_post.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/solvepost/ff_akz_vf_post.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solvepost/html/ff_akz_vf_post.html)
    * table: value and policy function by states and shocks
    * table: convergence and percentage policy function change by shock
    * graph: value + policy functions with levels, logged levels and percentages
    * mat: store all workspace matrixes, arrays, scalar values to matrixes
2. *akz* model [solution results graphing](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solvepost/html/ff_akz_vf_post_graph.html): [**m**](https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_akz/solvepost/ff_akz_vf_post_graph.m) \| [**publish html**](https://fanwangecon.github.io/CodeDynaAsset/m_akz/solvepost/html/ff_akz_vf_post_graph.html)
    * graph: value function by asset and shock
    * graph: consumption and asset choice levels
    * graph: consumption and asset logged levels
    * graph: consumption and asset as percentages of coh and assets
