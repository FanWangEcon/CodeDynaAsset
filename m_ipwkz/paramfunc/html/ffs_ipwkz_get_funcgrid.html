
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Generate States/Choices/Shocks Grids, get Functions (Interpolated + Percentage + Risky + Safe Asset)</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-07-02"><meta name="DC.source" content="ffs_ipwkz_get_funcgrid.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Generate States/Choices/Shocks Grids, get Functions (Interpolated + Percentage + Risky + Safe Asset)</h1><!--introduction--><p><b>back to <a href="https://fanwangecon.github.io">Fan</a>'s <a href="https://fanwangecon.github.io/CodeDynaAsset/">Dynamic Assets Repository</a> Table of Content.</b></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">FFS_IPWKZ_GET_FUNCGRID get funcs, params, states choices shocks grids</a></li><li><a href="#3">Default</a></li><li><a href="#4">Parse Parameters</a></li><li><a href="#5">Generate Asset and Choice Grid for 2nd stage Problem</a></li><li><a href="#6">Get Shock Grids</a></li><li><a href="#7">Get Equations</a></li><li><a href="#8">Generate Cash-on-Hand/State Matrix</a></li><li><a href="#9">Generate 1st Stage States: Interpolation Cash-on-hand Interpolation Grid</a></li><li><a href="#10">Generate 1st Stage Choices: Interpolation Cash-on-hand Interpolation Grid</a></li><li><a href="#11">Generate Interpolation Consumption Grid</a></li><li><a href="#12">Initialize armt_map to store, state, choice, shock matrixes</a></li><li><a href="#13">Store armt_map (1): 2nd Stage Problem Arrays and Matrixes</a></li><li><a href="#14">Store armt_map (2): First Stage Aggregate Savings</a></li><li><a href="#15">Store armt_map (3): First Stage Consumption and Cash-on-Hand Grids</a></li><li><a href="#16">Store armt_map (4): Shock Grids</a></li><li><a href="#17">Store Function Map</a></li><li><a href="#18">Graph</a></li><li><a href="#20">Graph 1: a and k choice grid graphs</a></li><li><a href="#21">Graph 2: coh by shock</a></li><li><a href="#22">Graph 3: 2nd stage coh reached by k' b' choices by index</a></li><li><a href="#23">Graph 4: 2nd stage coh reached by k' b' choices  by coh</a></li><li><a href="#24">Graph 5: 1st State Aggregate Savings Choices by COH interpolation grids</a></li><li><a href="#26">Display</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [armt_map, func_map] = ffs_ipwkz_get_funcgrid(varargin)
</pre><h2 id="2">FFS_IPWKZ_GET_FUNCGRID get funcs, params, states choices shocks grids</h2><p>centralized gateway for retrieving parameters, and solution grids and functions. Similar to <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html">ffs_akz_get_funcgrid</a> function. This code only deals with savings problems.</p><p>The graphs below show the difference between percentage choice grid and level choice grid. See comments by graphs below for explanations of differences between the choice grids here and choice grids in the ffs_akz_get_funcgrid function.</p><p>Note that the first stage w grid is based on cash-on-hand level reached by the coh(k,w-k,z) possible choice and shock combinations. This coh(k,w-k,z) &gt; max(w), which also means that at max(coh) grid, the w_perc choices at higher points require extrapolation. Extrapolation is based on nearest extrapolation.</p><p>@param param_map container parameter container</p><p>@param support_map container support container</p><p>@param bl_input_override boolean if true varargin contained param_map and support_map fully overrides local default. Local default is not invoked. This could be important for speed if this function is getting invoked within certain loops. Default is 0.</p><p>@return armt_map container container with states, choices and shocks grids that are inputs for grid based solution algorithm</p><p>@return func_map container container with function handles for consumption cash-on-hand etc.</p><p>@example</p><pre>  it_param_set = 2;
  bl_input_override = true;
  [param_map, support_map] = ffs_ipwkz_set_default_param(it_param_set);
  [armt_map, func_map] = ffs_ipwkz_get_funcgrid(param_map, support_map, bl_input_override);</pre><p>@include</p><div><ul><li><a href="https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_ipwkz/paramfunc/ffs_ipwkz_set_functions.m">ffs_ipwkz_set_functions</a></li><li><a href="https://github.com/FanWangEcon/CodeDynaAsset/blob/master/tools/ffto_gen_tauchen_jhl.m">ffto_gen_tauchen_jhl</a></li><li><a href="https://github.com/FanWangEcon/CodeDynaAsset/blob/master/tools/fft_gen_grid_loglin.m">fft_gen_grid_loglin</a></li></ul></div><h2 id="3">Default</h2><pre class="codeinput">bl_input_override = 0;
<span class="keyword">if</span> (length(varargin) == 3)
    bl_input_override = varargin{3};
<span class="keyword">end</span>
<span class="keyword">if</span> (bl_input_override)
    <span class="comment">% override when called from outside</span>
    [param_map, support_map, ~] = varargin{:};
<span class="keyword">else</span>
    <span class="comment">% default internal run</span>
    [param_map, support_map] = ffs_ipwkz_set_default_param();
    support_map(<span class="string">'bl_graph_funcgrids'</span>) = true;
    support_map(<span class="string">'bl_display_funcgrids'</span>) = true;

    <span class="comment">% to be able to visually see choice grid points</span>
    param_map(<span class="string">'fl_b_bd'</span>) = 0;
    param_map(<span class="string">'fl_w_min'</span>) = param_map(<span class="string">'fl_b_bd'</span>);
    param_map(<span class="string">'it_w_perc_n'</span>) = 25;
    param_map(<span class="string">'it_ak_perc_n'</span>) = 45;
    param_map(<span class="string">'fl_w_interp_grid_gap'</span>) = 2;
    param_map(<span class="string">'fl_coh_interp_grid_gap'</span>) = 2;
    default_maps = {param_map, support_map};

    <span class="comment">% numvarargs is the number of varagin inputted</span>
    [default_maps{1:length(varargin)}] = varargin{:};
    param_map = [param_map; default_maps{1}];
    support_map = [support_map; default_maps{2}];
<span class="keyword">end</span>
</pre><h2 id="4">Parse Parameters</h2><pre class="codeinput">params_group = values(param_map, {<span class="string">'it_z_n'</span>, <span class="string">'fl_z_mu'</span>, <span class="string">'fl_z_rho'</span>, <span class="string">'fl_z_sig'</span>});
[it_z_n, fl_z_mu, fl_z_rho, fl_z_sig] = params_group{:};

params_group = values(param_map, {<span class="string">'fl_b_bd'</span>, <span class="string">'fl_w_min'</span>, <span class="string">'fl_w_max'</span>, <span class="keyword">...</span>
    <span class="string">'it_w_perc_n'</span>, <span class="string">'fl_w_interp_grid_gap'</span>, <span class="string">'fl_coh_interp_grid_gap'</span>});
[fl_b_bd, fl_w_min, fl_w_max, <span class="keyword">...</span>
    it_w_perc_n, fl_w_interp_grid_gap, fl_coh_interp_grid_gap] = params_group{:};

params_group = values(param_map, {<span class="string">'fl_k_min'</span>, <span class="string">'fl_k_max'</span>, <span class="string">'it_ak_perc_n'</span>});
[fl_k_min, fl_k_max, it_ak_perc_n] = params_group{:};

params_group = values(param_map, {<span class="string">'fl_crra'</span>, <span class="string">'fl_c_min'</span>, <span class="string">'it_c_interp_grid_gap'</span>});
[fl_crra, fl_c_min, it_c_interp_grid_gap] = params_group{:};

params_group = values(param_map, {<span class="string">'fl_Amean'</span>, <span class="string">'fl_alpha'</span>, <span class="string">'fl_delta'</span>});
[fl_Amean, fl_alpha, fl_delta] = params_group{:};

params_group = values(param_map, {<span class="string">'fl_r_save'</span>, <span class="string">'fl_r_borr'</span>, <span class="string">'fl_w'</span>});
[fl_r_save, fl_r_borr, fl_w] = params_group{:};

params_group = values(support_map, {<span class="string">'bl_graph_funcgrids'</span>, <span class="string">'bl_display_funcgrids'</span>});
[bl_graph_funcgrids, bl_display_funcgrids] = params_group{:};
</pre><h2 id="5">Generate Asset and Choice Grid for 2nd stage Problem</h2><p>This generate triangular choice structure. Household choose total aggregate savings, and within that how much to put into risky capital and how much to put into safe assets, in percentages. See <a href="https://fanwangecon.github.io/CodeDynaAsset/m_ipwkz/paramfunc/html/ffs_ipwkz_set_default_param.html">ffs_ipwkz_set_default_param</a> for details.</p><pre class="codeinput"><span class="comment">% percentage grid for 1st stage choice problem, level grid for 2nd stage</span>
<span class="comment">% solving optimal k given w and z.</span>
ar_w_perc = linspace(0.001, 0.999, it_w_perc_n);
it_w_interp_n = (fl_w_max-fl_w_min)/(fl_w_interp_grid_gap);
ar_w_level = linspace(fl_w_min, fl_w_max, it_w_interp_n);

<span class="comment">% max k given w, need to consider the possibility of borrowing.</span>
ar_k_max = ar_w_level - fl_b_bd;

<span class="comment">% k percentage choice grid</span>
ar_ak_perc = linspace(0.001, 0.999, it_ak_perc_n);

<span class="comment">% 2nd stage percentage choice matrixes</span>
<span class="comment">% (ar_k_max') is it_w_interp_n by 1, and (ar_ak_perc) is 1 by it_ak_perc_n</span>
<span class="comment">% mt_k is a it_w_interp_n by it_ak_perc_n matrix of choice points of k'</span>
<span class="comment">% conditional on w, each column is a different w, each row for each col a</span>
<span class="comment">% different k' value.</span>
mt_k = (ar_k_max'*ar_ak_perc)';
mt_a = (ar_w_level - mt_k);

<span class="comment">% can not have choice that are beyond feasible bound given the percentage</span>
<span class="comment">% structure here.</span>
mt_bl_constrained = (mt_a &lt; fl_b_bd);
<span class="keyword">if</span> (sum(mt_bl_constrained) &gt; 0 )
    error(<span class="string">'at %s second stage choice points, percentage choice exceed bounds, can not happen'</span>,<span class="keyword">...</span>
          num2str(sum(mt_bl_constrained)));
<span class="keyword">end</span>

ar_a_meshk = mt_a(:);
ar_k_mesha = mt_k(:);
</pre><h2 id="6">Get Shock Grids</h2><pre class="codeinput">[~, mt_z_trans, ar_stationary, ar_z] = ffto_gen_tauchen_jhl(fl_z_mu,fl_z_rho,fl_z_sig,it_z_n);
</pre><h2 id="7">Get Equations</h2><pre class="codeinput">[f_util_log, f_util_crra, f_util_standin, f_prod, f_inc, f_coh, f_cons] = <span class="keyword">...</span>
    ffs_ipwkz_set_functions(fl_crra, fl_c_min, fl_Amean, fl_alpha, fl_delta, fl_r_save, fl_r_borr, fl_w);
</pre><h2 id="8">Generate Cash-on-Hand/State Matrix</h2><p>The endogenous state variable is cash-on-hand, it has it_z_n*it_a_n number of points, covering all reachable points when ar_a is the choice vector and ar_z is the shock vector. requires inputs from get Asset and choice grids, get shock grids, and get equations above.</p><pre class="codeinput">mt_coh_wkb = f_coh(ar_z, ar_a_meshk, ar_k_mesha);
mt_z_mesh_coh_wkb = repmat(ar_z, [size(mt_coh_wkb,1),1]);
</pre><h2 id="9">Generate 1st Stage States: Interpolation Cash-on-hand Interpolation Grid</h2><p>For the iwkz problems, we solve the problem along a grid of cash-on-hand values, the interpolate to find v(k',b',z) at (k',b') choices. Crucially, we have to coh matrxies</p><pre class="codeinput">fl_max_mt_coh = max(max(mt_coh_wkb));
fl_min_mt_coh = min(min(mt_coh_wkb));
it_coh_interp_n = (fl_max_mt_coh-fl_min_mt_coh)/(fl_coh_interp_grid_gap);
ar_interp_coh_grid = linspace(fl_min_mt_coh, fl_max_mt_coh, it_coh_interp_n);
[mt_interp_coh_grid_mesh_z, mt_z_mesh_coh_interp_grid] = ndgrid(ar_interp_coh_grid, ar_z);
mt_interp_coh_grid_mesh_w_perc = repmat(ar_interp_coh_grid, [it_w_perc_n, 1]);
</pre><h2 id="10">Generate 1st Stage Choices: Interpolation Cash-on-hand Interpolation Grid</h2><p>previously, our ar_w was the first stage choice grid, the grid was the same for all coh levels. Now, for each coh level, there is a different ar_w. ar_interp_coh_grid is (1 by ar_interp_coh_grid) and ar_w_perc is ( 1 by it_w_perc_n). Conditional on z, each choice matrix is (it_w_perc_n by ar_interp_coh_grid). Here we are pre-computing the choice matrix. This could be a large matrix if the choice grid is large. This is the matrix of aggregate savings choices</p><pre class="codeinput"><span class="keyword">if</span> (fl_min_mt_coh &lt; 0 )
    <span class="comment">% borrowing bound is below zero</span>
    mt_w_by_interp_coh_interp_grid = ((ar_interp_coh_grid-fl_min_mt_coh)'*ar_w_perc)' + fl_min_mt_coh;
<span class="keyword">else</span>
    <span class="comment">% savings only</span>
    mt_w_by_interp_coh_interp_grid = ((ar_interp_coh_grid)'*ar_w_perc)';
<span class="keyword">end</span>
</pre><h2 id="11">Generate Interpolation Consumption Grid</h2><p>We also interpolate over consumption to speed the program up. We only solve for u(c) at this grid for the iwkz problmes, and then interpolate other c values.</p><pre class="codeinput">fl_c_max = max(max(mt_coh_wkb)) - fl_b_bd;
it_interp_c_grid_n = (fl_c_max-fl_c_min)/(it_c_interp_grid_gap);
ar_interp_c_grid = linspace(fl_c_min, fl_c_max, it_interp_c_grid_n);
</pre><h2 id="12">Initialize armt_map to store, state, choice, shock matrixes</h2><pre class="codeinput">armt_map = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>, <span class="string">'ValueType'</span>,<span class="string">'any'</span>);
armtdesc_map = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>, <span class="string">'ValueType'</span>,<span class="string">'any'</span>);
</pre><h2 id="13">Store armt_map (1): 2nd Stage Problem Arrays and Matrixes</h2><pre class="codeinput">armt_map(<span class="string">'ar_ak_perc'</span>) = ar_ak_perc;
armt_map(<span class="string">'mt_k'</span>) = mt_k;
armt_map(<span class="string">'ar_a_meshk'</span>) = ar_a_meshk;
armt_map(<span class="string">'ar_k_mesha'</span>) = ar_k_mesha;
armt_map(<span class="string">'it_ameshk_n'</span>) = length(ar_a_meshk);
armt_map(<span class="string">'mt_coh_wkb'</span>) = mt_coh_wkb;
armt_map(<span class="string">'mt_z_mesh_coh_wkb'</span>) = mt_z_mesh_coh_wkb;
</pre><h2 id="14">Store armt_map (2): First Stage Aggregate Savings</h2><p>w = k' + b', w is aggregate Savings%</p><div><ol><li><b>ar_w_perc</b> 1st stage, percentage w choice given coh, at each coh level the number of choice points is the same for this problem with percentage grid points.</li><li><b>ar_w_level</b> 2nd stage, level of w over which we solve the optimal percentage k' choices. Need to generate interpolant based on this so that we know optimal k* given ar_w_perc(coh) in the 1st stage</li><li><b>mt_w_by_interp_coh_interp_grid</b> 1st stage, generate w(coh, percent), meaning the level of w given coh and the percentage grid of ar_w_perc. Mesh this with the coh grid, Rows here correspond to percentage of w choices, columns correspond to cash-on-hand. The columns of cash-on-hand is determined by ar_interp_coh_grid, because we solve the 1st stage problem at that coh grid.</li></ol></div><pre class="codeinput">armt_map(<span class="string">'ar_w_perc'</span>) = ar_w_perc;
armt_map(<span class="string">'ar_w_level'</span>) = ar_w_level;
armt_map(<span class="string">'mt_w_by_interp_coh_interp_grid'</span>) = mt_w_by_interp_coh_interp_grid;
armt_map(<span class="string">'mt_interp_coh_grid_mesh_w_perc'</span>) = mt_interp_coh_grid_mesh_w_perc;
</pre><h2 id="15">Store armt_map (3): First Stage Consumption and Cash-on-Hand Grids</h2><pre class="codeinput">armt_map(<span class="string">'ar_interp_c_grid'</span>) = ar_interp_c_grid;
armt_map(<span class="string">'ar_interp_coh_grid'</span>) = ar_interp_coh_grid;
armt_map(<span class="string">'mt_interp_coh_grid_mesh_z'</span>) = mt_interp_coh_grid_mesh_z;
armt_map(<span class="string">'mt_z_mesh_coh_interp_grid'</span>) = mt_z_mesh_coh_interp_grid;
</pre><h2 id="16">Store armt_map (4): Shock Grids</h2><pre class="codeinput">armt_map(<span class="string">'mt_z_trans'</span>) = mt_z_trans;
armt_map(<span class="string">'ar_stationary'</span>) = ar_stationary;
armt_map(<span class="string">'ar_z'</span>) = ar_z;
</pre><h2 id="17">Store Function Map</h2><pre class="codeinput">func_map = containers.Map(<span class="string">'KeyType'</span>,<span class="string">'char'</span>, <span class="string">'ValueType'</span>,<span class="string">'any'</span>);
func_map(<span class="string">'f_util_log'</span>) = f_util_log;
func_map(<span class="string">'f_util_crra'</span>) = f_util_crra;
func_map(<span class="string">'f_util_standin'</span>) = f_util_standin;
func_map(<span class="string">'f_prod'</span>) = f_prod;
func_map(<span class="string">'f_inc'</span>) = f_inc;
func_map(<span class="string">'f_coh'</span>) = f_coh;
func_map(<span class="string">'f_cons'</span>) = f_cons;
</pre><h2 id="18">Graph</h2><pre class="codeinput"><span class="keyword">if</span> (bl_graph_funcgrids)
</pre><h2 id="20">Graph 1: a and k choice grid graphs</h2><p>compare the figure here to the same figure in <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html">ffs_akz_get_funcgrid</a>. there the grid points are on an even grid, half of the grid points have NA. for the grid here, the grid points get denser as we get closer to low w = k'+b' levels. This is what is different visually about percentage points based choice grid for the 2nd stage problem.</p><pre class="codeinput">    figure(<span class="string">'PaperPosition'</span>, [0 0 7 4]);
    hold <span class="string">on</span>;

    chart = plot(mt_a, mt_k, <span class="string">'blue'</span>);

    clr = jet(numel(chart));
    <span class="keyword">for</span> m = 1:numel(chart)
       set(chart(m),<span class="string">'Color'</span>,clr(m,:))
    <span class="keyword">end</span>
    <span class="keyword">if</span> (length(ar_w_level) &lt;= 100)
        scatter(ar_a_meshk, ar_k_mesha, 3, <span class="string">'filled'</span>, <span class="keyword">...</span>
                <span class="string">'MarkerEdgeColor'</span>, <span class="string">'b'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>);
    <span class="keyword">end</span>
    xline(0);
    yline(0);

    title(<span class="string">'Choice Grids Conditional on k+a=w'</span>)
    ylabel(<span class="string">'Capital Choice'</span>)
    xlabel({<span class="string">'Saving'</span>})
    legend2plot = fliplr([1 round(numel(chart)/3) round((2*numel(chart))/4)  numel(chart)]);
    legendCell = cellstr(num2str(ar_w_level', <span class="string">'k+a=%3.2f'</span>));
    legend(chart(legend2plot), legendCell(legend2plot), <span class="string">'Location'</span>,<span class="string">'northeast'</span>);

    grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="ffs_ipwkz_get_funcgrid_01.png" alt=""> <h2 id="21">Graph 2: coh by shock</h2><p>compare the figure here to the same figure in <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html">ffs_akz_get_funcgrid</a>. there the grid points are on an even grid. Visually, one could see that the blue/red line segments here are always the same length, but in the ffs_akz_get_funcgrid figure, they are increasingly longer as we move towards the right. They are even because the number of percentage points available is constant regardless of w = k' + b' levels. But previously, the number of grid points available is increasing as w increases since choice grid is based on levels.</p><pre class="codeinput">    figure(<span class="string">'PaperPosition'</span>, [0 0 7 4]);
    chart = plot(mt_coh_wkb);
    clr = jet(numel(chart));
    <span class="keyword">for</span> m = 1:numel(chart)
       set(chart(m),<span class="string">'Color'</span>,clr(m,:))
    <span class="keyword">end</span>
    xline(0);
    yline(0);

    title(<span class="string">'Cash-on-Hand given w(k+b),k,z'</span>);
    ylabel(<span class="string">'Cash-on-Hand'</span>);
    xlabel({<span class="string">'Index of Cash-on-Hand Discrete Point'</span><span class="keyword">...</span>
        <span class="string">'Each Segment is a w=k+b; within segment increasing k'</span><span class="keyword">...</span>
        <span class="string">'For each w and z, coh maximizing k is different'</span>});

    legend2plot = fliplr([1 round(numel(chart)/3) round((2*numel(chart))/4)  numel(chart)]);
    legendCell = cellstr(num2str(ar_z', <span class="string">'shock=%3.2f'</span>));
    legend(chart(legend2plot), legendCell(legend2plot), <span class="string">'Location'</span>,<span class="string">'southeast'</span>);

    grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="ffs_ipwkz_get_funcgrid_02.png" alt=""> <h2 id="22">Graph 3: 2nd stage coh reached by k' b' choices by index</h2><pre class="codeinput">    figure(<span class="string">'PaperPosition'</span>, [0 0 7 4]);
    ar_coh_kpzgrid_unique = unique(sort(mt_coh_wkb(:)));
    scatter(1:length(ar_coh_kpzgrid_unique), ar_coh_kpzgrid_unique);
    xline(0);
    yline(0);
    title(<span class="string">'Cash-on-Hand given w(k+b),k,z'</span>);
    ylabel(<span class="string">'Cash-on-Hand'</span>);
    xlabel({<span class="string">'Index of Cash-on-Hand Discrete Point'</span>});
    grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="ffs_ipwkz_get_funcgrid_03.png" alt=""> <h2 id="23">Graph 4: 2nd stage coh reached by k' b' choices  by coh</h2><pre class="codeinput">    figure(<span class="string">'PaperPosition'</span>, [0 0 7 4]);
    ar_coh_kpzgrid_unique = unique(sort(mt_coh_wkb(:)));
    scatter(ar_coh_kpzgrid_unique, ar_coh_kpzgrid_unique, <span class="string">'.'</span>);
    xline(0);
    yline(0);
    title(<span class="string">'Cash-on-Hand given w(k+b),k,z; See Clearly Sparsity Density of Grid across Z'</span>);
    ylabel(<span class="string">'Cash-on-Hand'</span>);
    xlabel({<span class="string">'Cash-on-Hand'</span>});
    grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="ffs_ipwkz_get_funcgrid_04.png" alt=""> <h2 id="24">Graph 5: 1st State Aggregate Savings Choices by COH interpolation grids</h2><pre class="codeinput">    figure(<span class="string">'PaperPosition'</span>, [0 0 7 4]);
    hold <span class="string">on</span>;

    chart = plot(ar_interp_coh_grid, mt_w_by_interp_coh_interp_grid');

    clr = jet(numel(chart));
    <span class="keyword">for</span> m = 1:numel(chart)
       set(chart(m),<span class="string">'Color'</span>,clr(m,:))
    <span class="keyword">end</span>
    <span class="keyword">if</span> (length(ar_interp_coh_grid) &lt;= 100)
        [~, mt_interp_coh_grid_mesh_w_perc] = ndgrid(ar_w_perc, ar_interp_coh_grid);
        scatter(mt_interp_coh_grid_mesh_w_perc(:), mt_w_by_interp_coh_interp_grid(:), 3, <span class="string">'filled'</span>, <span class="keyword">...</span>
                <span class="string">'MarkerEdgeColor'</span>, <span class="string">'b'</span>, <span class="string">'MarkerFaceColor'</span>, <span class="string">'b'</span>);
    <span class="keyword">end</span>
    xline0 = xline(0);
    xline0.HandleVisibility = <span class="string">'off'</span>;
    yline0 = yline(0);
    yline0.HandleVisibility = <span class="string">'off'</span>;

    title(<span class="string">'Aggregate Savings Grid Given Cash-on-Hand'</span>);
    ylabel(<span class="string">'1st Stage Aggregate Savings Choices'</span>);
    xlabel({<span class="string">'Cash-on-Hand Levels (Interpolation Points)'</span>});

    legend2plot = fliplr([1 round(numel(chart)/3) round((2*numel(chart))/4)  numel(chart)]);
    legendCell = cellstr(num2str(ar_w_perc', <span class="string">'ar w perc=%3.2f'</span>));
    legend(chart(legend2plot), legendCell(legend2plot), <span class="string">'Location'</span>,<span class="string">'northwest'</span>);

    grid <span class="string">on</span>;
</pre><img vspace="5" hspace="5" src="ffs_ipwkz_get_funcgrid_05.png" alt=""> <pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="26">Display</h2><pre class="codeinput"><span class="keyword">if</span> (bl_display_funcgrids)

    disp(<span class="string">'ar_z'</span>);
    disp(size(ar_z));
    disp(ar_z);

    disp(<span class="string">'ar_w_level'</span>);
    disp(size(ar_w_level));
    disp(ar_w_level');

    disp(<span class="string">'mt_w_by_interp_coh_interp_grid'</span>);
    disp(size(mt_w_by_interp_coh_interp_grid));

    disp(<span class="string">'mt_z_trans'</span>);
    disp(size(mt_z_trans));
    disp(mt_z_trans');

    disp(<span class="string">'ar_interp_coh_grid'</span>);
    disp(size(ar_interp_coh_grid));
    summary(array2table(ar_interp_coh_grid'));

    disp(<span class="string">'ar_interp_c_grid'</span>);
    disp(size(ar_interp_c_grid));
    summary(array2table(ar_interp_c_grid'));

    disp(<span class="string">'mt_interp_coh_grid_mesh_z'</span>);
    disp(size(mt_interp_coh_grid_mesh_z));
    summary(array2table(mt_interp_coh_grid_mesh_z));

    disp(<span class="string">'mt_a'</span>);
    disp(size(mt_a));
<span class="comment">%     summary(array2table(mt_a));</span>
<span class="comment">%     disp(mt_a);</span>

    disp(<span class="string">'ar_a_meshk'</span>);
    disp(size(ar_a_meshk));
    summary(array2table(ar_a_meshk));
<span class="comment">%     disp(ar_a_meshk');</span>

    disp(<span class="string">'mt_k'</span>);
    disp(size(mt_k));
<span class="comment">%     summary(array2table(mt_k));</span>
<span class="comment">%     disp(mt_k);</span>

    disp(<span class="string">'ar_k_mesha'</span>);
    disp(size(ar_k_mesha));
    summary(array2table(ar_k_mesha));
<span class="comment">%     disp(ar_k_mesha');</span>

    disp(<span class="string">'mt_coh'</span>);
    disp(size(mt_coh_wkb));
    summary(array2table(mt_coh_wkb));
<span class="comment">%     disp(mt_coh_wkb);</span>

    param_map_keys = keys(func_map);
    param_map_vals = values(func_map);
    <span class="keyword">for</span> i = 1:length(func_map)
        st_display = strjoin([<span class="string">'pos ='</span> num2str(i) <span class="string">'; key ='</span> string(param_map_keys{i}) <span class="string">'; val ='</span> func2str(param_map_vals{i})]);
        disp(st_display);
    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><pre class="codeoutput">ar_z
     1    15

  Columns 1 through 7

    0.3474    0.4008    0.4623    0.5333    0.6152    0.7097    0.8186

  Columns 8 through 14

    0.9444    1.0894    1.2567    1.4496    1.6723    1.9291    2.2253

  Column 15

    2.5670

ar_w_level
     1    25

         0
    2.0833
    4.1667
    6.2500
    8.3333
   10.4167
   12.5000
   14.5833
   16.6667
   18.7500
   20.8333
   22.9167
   25.0000
   27.0833
   29.1667
   31.2500
   33.3333
   35.4167
   37.5000
   39.5833
   41.6667
   43.7500
   45.8333
   47.9167
   50.0000

mt_w_by_interp_coh_interp_grid
    25    28

mt_z_trans
    15    15

  Columns 1 through 7

    0.2602    0.1123    0.0371    0.0092    0.0017    0.0002    0.0000
    0.2683    0.1962    0.1049    0.0410    0.0117    0.0024    0.0004
    0.2555    0.2763    0.2185    0.1263    0.0534    0.0165    0.0037
    0.1492    0.2386    0.2790    0.2386    0.1492    0.0682    0.0228
    0.0534    0.1263    0.2185    0.2763    0.2555    0.1728    0.0854
    0.0117    0.0410    0.1049    0.1962    0.2683    0.2683    0.1962
    0.0016    0.0081    0.0309    0.0854    0.1728    0.2555    0.2763
    0.0001    0.0010    0.0056    0.0228    0.0682    0.1492    0.2386
    0.0000    0.0001    0.0006    0.0037    0.0165    0.0534    0.1263
    0.0000    0.0000    0.0000    0.0004    0.0024    0.0117    0.0410
    0.0000    0.0000    0.0000    0.0000    0.0002    0.0016    0.0081
    0.0000    0.0000    0.0000    0.0000    0.0000    0.0001    0.0010
    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000    0.0001
    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000
         0    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000

  Columns 8 through 14

    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000
    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000
    0.0006    0.0001    0.0000    0.0000    0.0000    0.0000    0.0000
    0.0056    0.0010    0.0001    0.0000    0.0000    0.0000    0.0000
    0.0309    0.0081    0.0016    0.0002    0.0000    0.0000    0.0000
    0.1049    0.0410    0.0117    0.0024    0.0004    0.0000    0.0000
    0.2185    0.1263    0.0534    0.0165    0.0037    0.0006    0.0001
    0.2790    0.2386    0.1492    0.0682    0.0228    0.0056    0.0010
    0.2185    0.2763    0.2555    0.1728    0.0854    0.0309    0.0081
    0.1049    0.1962    0.2683    0.2683    0.1962    0.1049    0.0410
    0.0309    0.0854    0.1728    0.2555    0.2763    0.2185    0.1263
    0.0056    0.0228    0.0682    0.1492    0.2386    0.2790    0.2386
    0.0006    0.0037    0.0165    0.0534    0.1263    0.2185    0.2763
    0.0000    0.0004    0.0024    0.0117    0.0410    0.1049    0.1962
    0.0000    0.0000    0.0002    0.0017    0.0092    0.0371    0.1123

  Column 15

    0.0000
    0.0000
    0.0000
    0.0000
    0.0000
    0.0000
    0.0000
    0.0001
    0.0016
    0.0117
    0.0534
    0.1492
    0.2555
    0.2683
    0.2602

ar_interp_coh_grid
     1    28


Variables:

    Var1: 28&times;1 double

        Values:

            Min       0.44365
            Median      28.86
            Max        57.277

ar_interp_c_grid
           1      572761


Variables:

    Var1: 572761&times;1 double

        Values:

            Min        0.001
            Median    28.639
            Max       57.277

mt_interp_coh_grid_mesh_z
    28    15


Variables:

    mt_interp_coh_grid_mesh_z1: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z2: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z3: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z4: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z5: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z6: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z7: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z8: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z9: 28&times;1 double

        Values:

            Min                 0.44365           
            Median                28.86           
            Max                  57.277           

    mt_interp_coh_grid_mesh_z10: 28&times;1 double

        Values:

            Min                  0.44365           
            Median                 28.86           
            Max                   57.277           

    mt_interp_coh_grid_mesh_z11: 28&times;1 double

        Values:

            Min                  0.44365           
            Median                 28.86           
            Max                   57.277           

    mt_interp_coh_grid_mesh_z12: 28&times;1 double

        Values:

            Min                  0.44365           
            Median                 28.86           
            Max                   57.277           

    mt_interp_coh_grid_mesh_z13: 28&times;1 double

        Values:

            Min                  0.44365           
            Median                 28.86           
            Max                   57.277           

    mt_interp_coh_grid_mesh_z14: 28&times;1 double

        Values:

            Min                  0.44365           
            Median                 28.86           
            Max                   57.277           

    mt_interp_coh_grid_mesh_z15: 28&times;1 double

        Values:

            Min                  0.44365           
            Median                 28.86           
            Max                   57.277           

mt_a
    45    25

ar_a_meshk
        1125           1


Variables:

    ar_a_meshk: 1125&times;1 double

        Values:

            Min               0   
            Median       9.1227   
            Max           49.95   

mt_k
    45    25

ar_k_mesha
        1125           1


Variables:

    ar_k_mesha: 1125&times;1 double

        Values:

            Min               0   
            Median       9.1227   
            Max           49.95   

mt_coh
        1125          15


Variables:

    mt_coh_wkb1: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        25.619   
            Max           51.939   

    mt_coh_wkb2: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        25.751   
            Max           51.995   

    mt_coh_wkb3: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        25.904   
            Max           52.076   

    mt_coh_wkb4: 1125&times;1 double

        Values:

            Min          0.44365   
            Median         26.08   
            Max           52.172   

    mt_coh_wkb5: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        26.248   
            Max           52.292   

    mt_coh_wkb6: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        26.487   
            Max            52.44   

    mt_coh_wkb7: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        26.734   
            Max           52.629   

    mt_coh_wkb8: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        27.032   
            Max           52.862   

    mt_coh_wkb9: 1125&times;1 double

        Values:

            Min          0.44365   
            Median        27.359   
            Max           53.157   

    mt_coh_wkb10: 1125&times;1 double

        Values:

            Min          0.44365    
            Median         27.76    
            Max           53.522    

    mt_coh_wkb11: 1125&times;1 double

        Values:

            Min          0.44365    
            Median        28.247    
            Max            53.98    

    mt_coh_wkb12: 1125&times;1 double

        Values:

            Min          0.44365    
            Median        28.831    
            Max           54.551    

    mt_coh_wkb13: 1125&times;1 double

        Values:

            Min          0.44365    
            Median        29.525    
            Max           55.267    

    mt_coh_wkb14: 1125&times;1 double

        Values:

            Min          0.44365    
            Median        30.214    
            Max            56.16    

    mt_coh_wkb15: 1125&times;1 double

        Values:

            Min          0.44365    
            Median         30.98    
            Max           57.277    

pos = 1 ; key = f_coh ; val = @(z,b,k)(f_prod(z,k)+k*(1-fl_delta)+fl_w+b.*(1+fl_r_save).*(b&gt;0)+b.*(1+fl_r_borr).*(b&lt;=0))
pos = 2 ; key = f_cons ; val = @(coh,bprime,kprime)(coh-kprime-bprime)
pos = 3 ; key = f_inc ; val = @(z,b,k)(f_prod(z,k)-(fl_delta)*k+fl_w+b.*(fl_r_save).*(b&gt;0)+b.*(fl_r_borr).*(b&lt;=0))
pos = 4 ; key = f_prod ; val = @(z,k)((fl_Amean.*(z)).*(k.^(fl_alpha)))
pos = 5 ; key = f_util_crra ; val = @(c)(((c).^(1-fl_crra)-1)./(1-fl_crra))
pos = 6 ; key = f_util_log ; val = @(c)log(c)
pos = 7 ; key = f_util_standin ; val = @(z,b,k)f_util_log(f_coh(z,b,k).*(f_coh(z,b,k)&gt;0)+fl_c_min.*(f_coh(z,b,k)&lt;=0))
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  Map with properties:

        Count: 18
      KeyType: char
    ValueType: any

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Generate States/Choices/Shocks Grids, get Functions (Interpolated + Percentage + Risky + Safe Asset)
% *back to <https://fanwangecon.github.io Fan>'s
% <https://fanwangecon.github.io/CodeDynaAsset/ Dynamic Assets Repository>
% Table of Content.*

%%
function [armt_map, func_map] = ffs_ipwkz_get_funcgrid(varargin)
%% FFS_IPWKZ_GET_FUNCGRID get funcs, params, states choices shocks grids
% centralized gateway for retrieving parameters, and solution grids and
% functions. Similar to
% <https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html
% ffs_akz_get_funcgrid> function. This code only deals with savings
% problems.
%
% The graphs below show the difference between percentage choice grid and
% level choice grid. See comments by graphs below for explanations of
% differences between the choice grids here and choice grids in the
% ffs_akz_get_funcgrid function.
%
% Note that the first stage w grid is based on cash-on-hand level reached
% by the coh(k,w-k,z) possible choice and shock combinations. This
% coh(k,w-k,z) > max(w), which also means that at max(coh) grid, the w_perc
% choices at higher points require extrapolation. Extrapolation is based on
% nearest extrapolation.
%
% @param param_map container parameter container
%
% @param support_map container support container
%
% @param bl_input_override boolean if true varargin contained param_map and
% support_map fully overrides local default. Local default is not invoked.
% This could be important for speed if this function is getting invoked
% within certain loops. Default is 0.
%
% @return armt_map container container with states, choices and shocks
% grids that are inputs for grid based solution algorithm
%
% @return func_map container container with function handles for
% consumption cash-on-hand etc.
%
% @example
%
%    it_param_set = 2;
%    bl_input_override = true;
%    [param_map, support_map] = ffs_ipwkz_set_default_param(it_param_set);
%    [armt_map, func_map] = ffs_ipwkz_get_funcgrid(param_map, support_map, bl_input_override);
%
% @include
%
% * <https://github.com/FanWangEcon/CodeDynaAsset/blob/master/m_ipwkz/paramfunc/ffs_ipwkz_set_functions.m ffs_ipwkz_set_functions>
% * <https://github.com/FanWangEcon/CodeDynaAsset/blob/master/tools/ffto_gen_tauchen_jhl.m ffto_gen_tauchen_jhl>
% * <https://github.com/FanWangEcon/CodeDynaAsset/blob/master/tools/fft_gen_grid_loglin.m fft_gen_grid_loglin>
%

%% Default

bl_input_override = 0;
if (length(varargin) == 3)
    bl_input_override = varargin{3};
end
if (bl_input_override)
    % override when called from outside
    [param_map, support_map, ~] = varargin{:};
else
    % default internal run
    [param_map, support_map] = ffs_ipwkz_set_default_param();
    support_map('bl_graph_funcgrids') = true;
    support_map('bl_display_funcgrids') = true;

    % to be able to visually see choice grid points
    param_map('fl_b_bd') = 0;
    param_map('fl_w_min') = param_map('fl_b_bd');
    param_map('it_w_perc_n') = 25;
    param_map('it_ak_perc_n') = 45;
    param_map('fl_w_interp_grid_gap') = 2;
    param_map('fl_coh_interp_grid_gap') = 2;
    default_maps = {param_map, support_map};

    % numvarargs is the number of varagin inputted
    [default_maps{1:length(varargin)}] = varargin{:};
    param_map = [param_map; default_maps{1}];
    support_map = [support_map; default_maps{2}];
end

%% Parse Parameters

params_group = values(param_map, {'it_z_n', 'fl_z_mu', 'fl_z_rho', 'fl_z_sig'});
[it_z_n, fl_z_mu, fl_z_rho, fl_z_sig] = params_group{:};

params_group = values(param_map, {'fl_b_bd', 'fl_w_min', 'fl_w_max', ...
    'it_w_perc_n', 'fl_w_interp_grid_gap', 'fl_coh_interp_grid_gap'});
[fl_b_bd, fl_w_min, fl_w_max, ...
    it_w_perc_n, fl_w_interp_grid_gap, fl_coh_interp_grid_gap] = params_group{:};

params_group = values(param_map, {'fl_k_min', 'fl_k_max', 'it_ak_perc_n'});
[fl_k_min, fl_k_max, it_ak_perc_n] = params_group{:};

params_group = values(param_map, {'fl_crra', 'fl_c_min', 'it_c_interp_grid_gap'});
[fl_crra, fl_c_min, it_c_interp_grid_gap] = params_group{:};

params_group = values(param_map, {'fl_Amean', 'fl_alpha', 'fl_delta'});
[fl_Amean, fl_alpha, fl_delta] = params_group{:};

params_group = values(param_map, {'fl_r_save', 'fl_r_borr', 'fl_w'});
[fl_r_save, fl_r_borr, fl_w] = params_group{:};

params_group = values(support_map, {'bl_graph_funcgrids', 'bl_display_funcgrids'});
[bl_graph_funcgrids, bl_display_funcgrids] = params_group{:};

%% Generate Asset and Choice Grid for 2nd stage Problem
% This generate triangular choice structure. Household choose total
% aggregate savings, and within that how much to put into risky capital and
% how much to put into safe assets, in percentages. See
% <https://fanwangecon.github.io/CodeDynaAsset/m_ipwkz/paramfunc/html/ffs_ipwkz_set_default_param.html
% ffs_ipwkz_set_default_param> for details.

% percentage grid for 1st stage choice problem, level grid for 2nd stage
% solving optimal k given w and z.
ar_w_perc = linspace(0.001, 0.999, it_w_perc_n);
it_w_interp_n = (fl_w_max-fl_w_min)/(fl_w_interp_grid_gap);
ar_w_level = linspace(fl_w_min, fl_w_max, it_w_interp_n);

% max k given w, need to consider the possibility of borrowing.
ar_k_max = ar_w_level - fl_b_bd;

% k percentage choice grid
ar_ak_perc = linspace(0.001, 0.999, it_ak_perc_n);

% 2nd stage percentage choice matrixes
% (ar_k_max') is it_w_interp_n by 1, and (ar_ak_perc) is 1 by it_ak_perc_n
% mt_k is a it_w_interp_n by it_ak_perc_n matrix of choice points of k'
% conditional on w, each column is a different w, each row for each col a
% different k' value.
mt_k = (ar_k_max'*ar_ak_perc)';
mt_a = (ar_w_level - mt_k);

% can not have choice that are beyond feasible bound given the percentage
% structure here.
mt_bl_constrained = (mt_a < fl_b_bd);
if (sum(mt_bl_constrained) > 0 )
    error('at %s second stage choice points, percentage choice exceed bounds, can not happen',...
          num2str(sum(mt_bl_constrained)));
end

ar_a_meshk = mt_a(:);
ar_k_mesha = mt_k(:);

%% Get Shock Grids

[~, mt_z_trans, ar_stationary, ar_z] = ffto_gen_tauchen_jhl(fl_z_mu,fl_z_rho,fl_z_sig,it_z_n);

%% Get Equations

[f_util_log, f_util_crra, f_util_standin, f_prod, f_inc, f_coh, f_cons] = ...
    ffs_ipwkz_set_functions(fl_crra, fl_c_min, fl_Amean, fl_alpha, fl_delta, fl_r_save, fl_r_borr, fl_w);

%% Generate Cash-on-Hand/State Matrix
% The endogenous state variable is cash-on-hand, it has it_z_n*it_a_n
% number of points, covering all reachable points when ar_a is the choice
% vector and ar_z is the shock vector. requires inputs from get Asset and
% choice grids, get shock grids, and get equations above.

mt_coh_wkb = f_coh(ar_z, ar_a_meshk, ar_k_mesha);
mt_z_mesh_coh_wkb = repmat(ar_z, [size(mt_coh_wkb,1),1]);

%% Generate 1st Stage States: Interpolation Cash-on-hand Interpolation Grid
% For the iwkz problems, we solve the problem along a grid of cash-on-hand
% values, the interpolate to find v(k',b',z) at (k',b') choices. Crucially,
% we have to coh matrxies

fl_max_mt_coh = max(max(mt_coh_wkb));
fl_min_mt_coh = min(min(mt_coh_wkb));
it_coh_interp_n = (fl_max_mt_coh-fl_min_mt_coh)/(fl_coh_interp_grid_gap);
ar_interp_coh_grid = linspace(fl_min_mt_coh, fl_max_mt_coh, it_coh_interp_n);
[mt_interp_coh_grid_mesh_z, mt_z_mesh_coh_interp_grid] = ndgrid(ar_interp_coh_grid, ar_z);
mt_interp_coh_grid_mesh_w_perc = repmat(ar_interp_coh_grid, [it_w_perc_n, 1]);

%% Generate 1st Stage Choices: Interpolation Cash-on-hand Interpolation Grid
% previously, our ar_w was the first stage choice grid, the grid was the
% same for all coh levels. Now, for each coh level, there is a different
% ar_w. ar_interp_coh_grid is (1 by ar_interp_coh_grid) and ar_w_perc is (
% 1 by it_w_perc_n). Conditional on z, each choice matrix is (it_w_perc_n
% by ar_interp_coh_grid). Here we are pre-computing the choice matrix. This
% could be a large matrix if the choice grid is large. This is the matrix
% of aggregate savings choices
%

if (fl_min_mt_coh < 0 )
    % borrowing bound is below zero
    mt_w_by_interp_coh_interp_grid = ((ar_interp_coh_grid-fl_min_mt_coh)'*ar_w_perc)' + fl_min_mt_coh;
else
    % savings only
    mt_w_by_interp_coh_interp_grid = ((ar_interp_coh_grid)'*ar_w_perc)';
end


%% Generate Interpolation Consumption Grid
% We also interpolate over consumption to speed the program up. We only
% solve for u(c) at this grid for the iwkz problmes, and then interpolate
% other c values.

fl_c_max = max(max(mt_coh_wkb)) - fl_b_bd;
it_interp_c_grid_n = (fl_c_max-fl_c_min)/(it_c_interp_grid_gap);
ar_interp_c_grid = linspace(fl_c_min, fl_c_max, it_interp_c_grid_n);

%% Initialize armt_map to store, state, choice, shock matrixes

armt_map = containers.Map('KeyType','char', 'ValueType','any');
armtdesc_map = containers.Map('KeyType','char', 'ValueType','any');

%% Store armt_map (1): 2nd Stage Problem Arrays and Matrixes
armt_map('ar_ak_perc') = ar_ak_perc;
armt_map('mt_k') = mt_k;
armt_map('ar_a_meshk') = ar_a_meshk;
armt_map('ar_k_mesha') = ar_k_mesha;
armt_map('it_ameshk_n') = length(ar_a_meshk);
armt_map('mt_coh_wkb') = mt_coh_wkb;
armt_map('mt_z_mesh_coh_wkb') = mt_z_mesh_coh_wkb;

%% Store armt_map (2): First Stage Aggregate Savings
% w = k' + b', w is aggregate Savings%
%
% # *ar_w_perc* 1st stage, percentage w choice given coh, at each coh
% level the number of choice points is the same for this problem with
% percentage grid points. 
% # *ar_w_level* 2nd stage, level of w over which we solve the optimal
% percentage k' choices. Need to generate interpolant based on this so that
% we know optimal k* given ar_w_perc(coh) in the 1st stage
% # *mt_w_by_interp_coh_interp_grid* 1st stage, generate w(coh, percent),
% meaning the level of w given coh and the percentage grid of ar_w_perc.
% Mesh this with the coh grid, Rows here correspond to percentage of w
% choices, columns correspond to cash-on-hand. The columns of cash-on-hand
% is determined by ar_interp_coh_grid, because we solve the 1st stage
% problem at that coh grid. 
%

armt_map('ar_w_perc') = ar_w_perc;
armt_map('ar_w_level') = ar_w_level;
armt_map('mt_w_by_interp_coh_interp_grid') = mt_w_by_interp_coh_interp_grid;
armt_map('mt_interp_coh_grid_mesh_w_perc') = mt_interp_coh_grid_mesh_w_perc;

%% Store armt_map (3): First Stage Consumption and Cash-on-Hand Grids

armt_map('ar_interp_c_grid') = ar_interp_c_grid;
armt_map('ar_interp_coh_grid') = ar_interp_coh_grid;
armt_map('mt_interp_coh_grid_mesh_z') = mt_interp_coh_grid_mesh_z;
armt_map('mt_z_mesh_coh_interp_grid') = mt_z_mesh_coh_interp_grid;

%% Store armt_map (4): Shock Grids
armt_map('mt_z_trans') = mt_z_trans;
armt_map('ar_stationary') = ar_stationary;
armt_map('ar_z') = ar_z;

%% Store Function Map
func_map = containers.Map('KeyType','char', 'ValueType','any');
func_map('f_util_log') = f_util_log;
func_map('f_util_crra') = f_util_crra;
func_map('f_util_standin') = f_util_standin;
func_map('f_prod') = f_prod;
func_map('f_inc') = f_inc;
func_map('f_coh') = f_coh;
func_map('f_cons') = f_cons;

%% Graph

if (bl_graph_funcgrids)

    %% Graph 1: a and k choice grid graphs
    % compare the figure here to the same figure in
    % <https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html
    % ffs_akz_get_funcgrid>. there the grid points are on an even grid,
    % half of the grid points have NA. for the grid here, the grid points
    % get denser as we get closer to low w = k'+b' levels. This is what is
    % different visually about percentage points based choice grid for the
    % 2nd stage problem.

    figure('PaperPosition', [0 0 7 4]);
    hold on;

    chart = plot(mt_a, mt_k, 'blue');

    clr = jet(numel(chart));
    for m = 1:numel(chart)
       set(chart(m),'Color',clr(m,:))
    end
    if (length(ar_w_level) <= 100)
        scatter(ar_a_meshk, ar_k_mesha, 3, 'filled', ...
                'MarkerEdgeColor', 'b', 'MarkerFaceColor', 'b');
    end
    xline(0);
    yline(0);

    title('Choice Grids Conditional on k+a=w')
    ylabel('Capital Choice')
    xlabel({'Saving'})
    legend2plot = fliplr([1 round(numel(chart)/3) round((2*numel(chart))/4)  numel(chart)]);
    legendCell = cellstr(num2str(ar_w_level', 'k+a=%3.2f'));
    legend(chart(legend2plot), legendCell(legend2plot), 'Location','northeast');

    grid on;

    %% Graph 2: coh by shock
    % compare the figure here to the same figure in
    % <https://fanwangecon.github.io/CodeDynaAsset/m_akz/paramfunc/html/ffs_akz_get_funcgrid.html
    % ffs_akz_get_funcgrid>. there the grid points are on an even grid.
    % Visually, one could see that the blue/red line segments here are
    % always the same length, but in the ffs_akz_get_funcgrid figure, they
    % are increasingly longer as we move towards the right. They are even
    % because the number of percentage points available is constant
    % regardless of w = k' + b' levels. But previously, the number of grid
    % points available is increasing as w increases since choice grid is
    % based on levels.
    %

    figure('PaperPosition', [0 0 7 4]);
    chart = plot(mt_coh_wkb);
    clr = jet(numel(chart));
    for m = 1:numel(chart)
       set(chart(m),'Color',clr(m,:))
    end
    xline(0);
    yline(0);

    title('Cash-on-Hand given w(k+b),k,z');
    ylabel('Cash-on-Hand');
    xlabel({'Index of Cash-on-Hand Discrete Point'...
        'Each Segment is a w=k+b; within segment increasing k'...
        'For each w and z, coh maximizing k is different'});

    legend2plot = fliplr([1 round(numel(chart)/3) round((2*numel(chart))/4)  numel(chart)]);
    legendCell = cellstr(num2str(ar_z', 'shock=%3.2f'));
    legend(chart(legend2plot), legendCell(legend2plot), 'Location','southeast');

    grid on;


    %% Graph 3: 2nd stage coh reached by k' b' choices by index

    figure('PaperPosition', [0 0 7 4]);
    ar_coh_kpzgrid_unique = unique(sort(mt_coh_wkb(:)));
    scatter(1:length(ar_coh_kpzgrid_unique), ar_coh_kpzgrid_unique);
    xline(0);
    yline(0);
    title('Cash-on-Hand given w(k+b),k,z');
    ylabel('Cash-on-Hand');
    xlabel({'Index of Cash-on-Hand Discrete Point'});
    grid on;

    %% Graph 4: 2nd stage coh reached by k' b' choices  by coh

    figure('PaperPosition', [0 0 7 4]);
    ar_coh_kpzgrid_unique = unique(sort(mt_coh_wkb(:)));
    scatter(ar_coh_kpzgrid_unique, ar_coh_kpzgrid_unique, '.');
    xline(0);
    yline(0);
    title('Cash-on-Hand given w(k+b),k,z; See Clearly Sparsity Density of Grid across Z');
    ylabel('Cash-on-Hand');
    xlabel({'Cash-on-Hand'});
    grid on;

    %% Graph 5: 1st State Aggregate Savings Choices by COH interpolation grids

    figure('PaperPosition', [0 0 7 4]);
    hold on;

    chart = plot(ar_interp_coh_grid, mt_w_by_interp_coh_interp_grid');

    clr = jet(numel(chart));
    for m = 1:numel(chart)
       set(chart(m),'Color',clr(m,:))
    end
    if (length(ar_interp_coh_grid) <= 100)
        [~, mt_interp_coh_grid_mesh_w_perc] = ndgrid(ar_w_perc, ar_interp_coh_grid);
        scatter(mt_interp_coh_grid_mesh_w_perc(:), mt_w_by_interp_coh_interp_grid(:), 3, 'filled', ...
                'MarkerEdgeColor', 'b', 'MarkerFaceColor', 'b');
    end
    xline0 = xline(0);
    xline0.HandleVisibility = 'off';
    yline0 = yline(0);
    yline0.HandleVisibility = 'off';

    title('Aggregate Savings Grid Given Cash-on-Hand');
    ylabel('1st Stage Aggregate Savings Choices');
    xlabel({'Cash-on-Hand Levels (Interpolation Points)'});

    legend2plot = fliplr([1 round(numel(chart)/3) round((2*numel(chart))/4)  numel(chart)]);
    legendCell = cellstr(num2str(ar_w_perc', 'ar w perc=%3.2f'));
    legend(chart(legend2plot), legendCell(legend2plot), 'Location','northwest');

    grid on;

end

%% Display

if (bl_display_funcgrids)

    disp('ar_z');
    disp(size(ar_z));
    disp(ar_z);

    disp('ar_w_level');
    disp(size(ar_w_level));
    disp(ar_w_level');

    disp('mt_w_by_interp_coh_interp_grid');
    disp(size(mt_w_by_interp_coh_interp_grid));

    disp('mt_z_trans');
    disp(size(mt_z_trans));
    disp(mt_z_trans');

    disp('ar_interp_coh_grid');
    disp(size(ar_interp_coh_grid));
    summary(array2table(ar_interp_coh_grid'));

    disp('ar_interp_c_grid');
    disp(size(ar_interp_c_grid));
    summary(array2table(ar_interp_c_grid'));

    disp('mt_interp_coh_grid_mesh_z');
    disp(size(mt_interp_coh_grid_mesh_z));
    summary(array2table(mt_interp_coh_grid_mesh_z));

    disp('mt_a');
    disp(size(mt_a));
%     summary(array2table(mt_a));
%     disp(mt_a);

    disp('ar_a_meshk');
    disp(size(ar_a_meshk));
    summary(array2table(ar_a_meshk));
%     disp(ar_a_meshk');

    disp('mt_k');
    disp(size(mt_k));
%     summary(array2table(mt_k));
%     disp(mt_k);

    disp('ar_k_mesha');
    disp(size(ar_k_mesha));
    summary(array2table(ar_k_mesha));
%     disp(ar_k_mesha');

    disp('mt_coh');
    disp(size(mt_coh_wkb));
    summary(array2table(mt_coh_wkb));
%     disp(mt_coh_wkb);

    param_map_keys = keys(func_map);
    param_map_vals = values(func_map);
    for i = 1:length(func_map)
        st_display = strjoin(['pos =' num2str(i) '; key =' string(param_map_keys{i}) '; val =' func2str(param_map_vals{i})]);
        disp(st_display);
    end

end

end

##### SOURCE END #####
--></body></html>