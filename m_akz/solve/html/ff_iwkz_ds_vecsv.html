
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Derive Distributions for Risky + Safe Asets + Interpolated Distribution (Analytical)</title><meta name="generator" content="MATLAB 9.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2019-07-03"><meta name="DC.source" content="ff_iwkz_ds_vecsv.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Derive Distributions for Risky + Safe Asets + Interpolated Distribution (Analytical)</h1><!--introduction--><p><b>back to <a href="https://fanwangecon.github.io">Fan</a>'s <a href="https://fanwangecon.github.io/CodeDynaAsset/">Dynamic Assets Repository</a> Table of Content.</b></p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#2">FF_IWKZ_DS finds the stationary asset distributions</a></li><li><a href="#3">Default</a></li><li><a href="#4">Parse Parameters</a></li><li><a href="#5">Start Profiler and Timer</a></li><li><a href="#6">A. Get Size of Endogenous and Exogenous State</a></li><li><a href="#7">B. Solve for Index</a></li><li><a href="#8">C. Expand Index so Matches Full States Index Dimension</a></li><li><a href="#9">D. Transition Probabilities from (M by M) to (NxM) by M</a></li><li><a href="#10">E. Fill mt_pol_idx_mesh_idx to mt_full_trans_mat SPARSE</a></li><li><a href="#11">F. Stationary Distribution <b>Method A</b>, Eigenvector Approach</a></li><li><a href="#12">G. Stationary Vector to Stationary Matrix in Original Dimensions</a></li><li><a href="#13">End Time and Profiler</a></li><li><a href="#14"><b>f(y), f(c), f(a), f(k)</b>: Generate Key Distributional Statistics for Each outcome</a></li></ul></div><pre class="codeinput"><span class="keyword">function</span> [result_map] = ff_iwkz_ds_vecsv(varargin)
</pre><h2 id="2">FF_IWKZ_DS finds the stationary asset distributions</h2><p>Building on the Two Assets Two-Step Interpolated Dynamic Programming Problem <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_vf_vecsv.html">ff_iwkz_vf_vecsv</a>, here we solve for the asset distribution. This version of the program is semi-analytical.</p><p>This is the two-stage with interpolation version of <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_ds_vecsv.html">ff_akz_ds_vecsv</a>. See that file for additional descriptions and comparisons. These two functions are nearly identical</p><p>The code here works when we are looking for the distribution of f(a,z), where a'(a,z,z'), meaning that the a next period is determined by a last period and some shock last period as well as shock this period. a here is cash-on-hand. This contrasts with <a href="https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vecsv.html">ff_az_ds_vecsv</a>, which works for a'(a,z), a' can not be a function of z'.</p><p>@example</p><pre>  % Get Default Parameters
  it_param_set = 6;
  [param_map, support_map] = ffs_az_set_default_param(it_param_set);
  % Change Keys in param_map
  param_map('it_w_n') = 750;
  param_map('it_ak_n') = param_map('it_w_n');
  param_map('it_z_n') = 11;
  param_map('fl_a_max') = 100;
  param_map('fl_w') = 1.3;
  % Change Keys support_map
  support_map('bl_display') = false;
  support_map('bl_post') = true;
  support_map('bl_display_final') = false;
  % Call Program with external parameters that override defaults
  ff_iwkz_ds_vecsv(param_map, support_map);</pre><p>@include</p><div><ul><li><a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_vf_vecsv.html">ff_wkz_vf_vecsv</a></li><li><a href="https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_ds_post_stats.html">ff_az_ds_post_stats</a></li><li><a href="https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_stats.html">fft_disc_rand_var_stats</a></li><li><a href="https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_mass2outcomes.html">fft_disc_rand_var_mass2outcomes</a></li></ul></div><p>@seealso</p><div><ul><li>derive distribution f(y'(y,z)) one asset <b>loop</b>: <a href="https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds.html">ff_az_ds</a></li><li>derive distribution f(y'({x,y},z)) two assets <b>loop</b>: <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_ds.html">ff_akz_ds</a></li><li>derive distribution f(y'({x,y},z, <b>z'</b>)) two assets <b>loop</b>: <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_ds.html">ff_iwkz_ds</a></li><li>derive distribution f(y'({y},z)) or f(y'({x,y},z)) <b>vectorized</b>: <a href="https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vec.html">ff_az_ds_vec</a></li><li>derive distribution f(y'({y},z, <b>z'</b>)) or f(y'({x,y},z, <b>z'</b>)) <b>vectorized</b>: <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_ds_vec.html">ff_iwkz_ds_vec</a></li><li>derive distribution f(y'({y},z)) or f(y'({x,y},z)) <b>semi-analytical</b>: <a href="https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vecsv.html">ff_az_ds_vecsv</a></li><li>derive distribution f(y'({y},z, <b>z'</b>)) or f(y'({x,y},z, <b>z'</b>)) <b>semi-analytical</b>: <a href="https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_ds_vecsv.html">ff_iwkz_ds_vecsv</a></li></ul></div><h2 id="3">Default</h2><p>Program can be externally invoked with <i>az</i>, <i>abz</i> or various other programs. By default, program invokes using <i>az</i> model programs:</p><div><ol><li>it_subset = 5 is basic invoke quick test</li><li>it_subset = 6 is invoke full test</li><li>it_subset = 7 is profiling invoke</li><li>it_subset = 8 is matlab publish</li><li>it_subset = 9 is invoke operational (only final stats) and coh graph</li></ol></div><pre class="codeinput">params_len = length(varargin);
bl_input_override = 0;
<span class="keyword">if</span> (params_len == 6)
    bl_input_override = varargin{6};
<span class="keyword">end</span>

<span class="keyword">if</span> (bl_input_override)
    <span class="comment">% if invoked from outside override fully</span>
    [param_map, support_map, armt_map, func_map, result_map, ~] = varargin{:};

<span class="keyword">else</span>
    <span class="comment">% default invoke</span>
    close <span class="string">all</span>;

    it_param_set = 8;
    st_akz_or_iwkz = <span class="string">'iwkz'</span>;

    bl_input_override = true;

    <span class="comment">% 1. Generate Parameters</span>
    [param_map, support_map] = ffs_akz_set_default_param(it_param_set);

    <span class="comment">% Note: param_map and support_map can be adjusted here or outside to override defaults</span>
    <span class="comment">% param_map('it_w_n') = 50;</span>
    <span class="comment">% param_map('it_z_n') = 15;</span>

    param_map(<span class="string">'st_analytical_stationary_type'</span>) = <span class="string">'eigenvector'</span>;

    <span class="comment">% 2. Generate function and grids</span>
    [armt_map, func_map] = ffs_akz_get_funcgrid(param_map, support_map, bl_input_override); <span class="comment">% 1 for override</span>

    <span class="comment">% 3. Solve value and policy function using ff_iwkz_vf_vecsv</span>
    <span class="keyword">if</span> (strcmp(st_akz_or_iwkz, <span class="string">'iwkz'</span>))
        [result_map] = ff_iwkz_vf_vecsv(param_map, support_map, armt_map, func_map);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><img vspace="5" hspace="5" src="ff_iwkz_ds_vecsv_01.png" alt=""> <img vspace="5" hspace="5" src="ff_iwkz_ds_vecsv_02.png" alt=""> <h2 id="4">Parse Parameters</h2><pre class="codeinput"><span class="comment">% append function name</span>
st_func_name = <span class="string">'ff_iwkz_ds_vecsv'</span>;
support_map(<span class="string">'st_profile_name_main'</span>) = [st_func_name support_map(<span class="string">'st_profile_name_main'</span>)];
support_map(<span class="string">'st_mat_name_main'</span>) = [st_func_name support_map(<span class="string">'st_mat_name_main'</span>)];
support_map(<span class="string">'st_img_name_main'</span>) = [st_func_name support_map(<span class="string">'st_img_name_main'</span>)];

<span class="comment">% result_map</span>
<span class="comment">% ar_st_pol_names is from section _Process Optimal Choices_ in the value</span>
<span class="comment">% function code.</span>
params_group = values(result_map, {<span class="string">'cl_mt_pol_a'</span>, <span class="string">'cl_mt_pol_k'</span>});
[cl_mt_pol_a, cl_mt_pol_k] = params_group{:};
[mt_pol_a, mt_pol_k] = deal(cl_mt_pol_a{1}, cl_mt_pol_k{1});

<span class="comment">% func_map</span>
params_group = values(func_map, {<span class="string">'f_coh'</span>});
[f_coh] = params_group{:};

<span class="comment">% armt_map</span>
params_group = values(armt_map, {<span class="string">'mt_z_trans'</span>, <span class="string">'ar_z'</span>});
[mt_z_trans, ar_z] = params_group{:};
params_group = values(armt_map, {<span class="string">'ar_interp_coh_grid'</span>});
[ar_interp_coh_grid] = params_group{:};

<span class="comment">% param_map</span>
params_group = values(param_map, {<span class="string">'it_z_n'</span>, <span class="string">'it_maxiter_dist'</span>, <span class="string">'fl_tol_dist'</span>});
[it_z_n, it_maxiter_dist, fl_tol_dist] = params_group{:};
params_group = values(param_map, { <span class="string">'it_trans_power_dist'</span>, <span class="string">'st_analytical_stationary_type'</span>});
[it_trans_power_dist, st_analytical_stationary_type] = params_group{:};

<span class="comment">% support_map</span>
params_group = values(support_map, {<span class="string">'bl_profile_dist'</span>, <span class="string">'st_profile_path'</span>, <span class="keyword">...</span>
    <span class="string">'st_profile_prefix'</span>, <span class="string">'st_profile_name_main'</span>, <span class="string">'st_profile_suffix'</span>,<span class="keyword">...</span>
    <span class="string">'bl_time'</span>, <span class="string">'bl_display_dist'</span>, <span class="string">'it_display_every'</span>});
[bl_profile_dist, st_profile_path, <span class="keyword">...</span>
    st_profile_prefix, st_profile_name_main, st_profile_suffix, <span class="keyword">...</span>
    bl_time, bl_display_dist, it_display_every] = params_group{:};
</pre><h2 id="5">Start Profiler and Timer</h2><pre class="codeinput"><span class="comment">% Start Profile</span>
<span class="keyword">if</span> (bl_profile_dist)
    close <span class="string">all</span>;
    profile <span class="string">off</span>;
    profile <span class="string">on</span>;
<span class="keyword">end</span>

<span class="comment">% Start Timer</span>
<span class="keyword">if</span> (bl_time)
    tic;
<span class="keyword">end</span>
</pre><h2 id="6">A. Get Size of Endogenous and Exogenous State</h2><pre class="codeinput">it_endostates_n = length(ar_interp_coh_grid);
it_exostates_n = length(ar_z);
</pre><h2 id="7">B. Solve for Index</h2><p>The model is solved by interpolating over cash-on-hand. The optimal choices do not map to specific points on the cash-on-hand grid. Find the index of the cash-on-hand vector that is the closest to the coh'(a'(coh,z),k'(coh,z),z').</p><p>Since we have <b>z_n</b> elements of shocks, and <b>coh_n</b> elements of the cash-on-hand grid, there are (coh_n x z_n) possible combinations of states at period t. In period t+1, there are (coh_n x z_n) by (z_n) possible/reachable cash-on-hand points. We find the index of all these reachable coh' points on the interpolation cash-on-hand grid.</p><pre class="codeinput"><span class="comment">% 1. *mt_coh_prime* is (coh_n x z_n) by (z_n)</span>
<span class="comment">% coh'(z', a'(coh,z), k'(coh,z))</span>
mt_coh_prime = f_coh(ar_z, mt_pol_a(:), mt_pol_k(:));

<span class="comment">% 2. *mt_coh_prime_on_grid_idx* is (coh_n x z_n) by (z_n):</span>
<span class="comment">% index for coh'(a,k,z')</span>
[~, ar_coh_prime_on_grid_idx] = min(abs(mt_coh_prime(:)' - ar_interp_coh_grid'));
mt_coh_prime_on_grid_idx = reshape(ar_coh_prime_on_grid_idx, size(mt_coh_prime));
</pre><h2 id="8">C. Expand Index so Matches Full States Index Dimension</h2><p>The index above matches the index in the cash-on-hand grid, but now, the state space is cash-on-hand jointly with shocks, that is the full states markov's states. So if there are two shocks and two cash-on-hand grid points, the cash-on-hand grid points would have been [1,2] and [1,2], but depending on which z' they match up to, they would now be [1,2] if matching to the first z', and [3,4] if matching to the second z'.</p><pre class="codeinput"><span class="comment">% mt_pol_idx_mesh_max is (NxM) by M, mt_pol_idx is N by M</span>
mt_pol_idx_mesh_max = mt_coh_prime_on_grid_idx + (0:1:(it_exostates_n-1))*it_endostates_n;
</pre><h2 id="9">D. Transition Probabilities from (M by M) to (NxM) by M</h2><p>Probability comes from the shock transition matrix, which is now duplicated for all cash-on-hand grid elements</p><pre class="codeinput">mt_trans_prob = reshape(repmat(mt_z_trans(:)', <span class="keyword">...</span>
    [it_endostates_n, 1]), [it_endostates_n*it_exostates_n, it_exostates_n]);
</pre><h2 id="10">E. Fill mt_pol_idx_mesh_idx to mt_full_trans_mat SPARSE</h2><p>Try to always use sparse matrix, unless grid sizes very small, keeping non-sparse code here for comparison. Sparse matrix is important for allowing the code to be fast and memory efficient. Otherwise this method is much slower than iterative method.</p><pre class="codeinput">i = mt_pol_idx_mesh_max(:);
j = repmat((1:1:it_endostates_n*it_exostates_n),[1,it_exostates_n])';
v = mt_trans_prob(:);
m = it_endostates_n*it_exostates_n;
n = it_endostates_n*it_exostates_n;
mt_full_trans_mat = sparse(i, j, v, m, n);
</pre><h2 id="11">F. Stationary Distribution <b>Method A</b>, Eigenvector Approach</h2><p>Given that markov chain we have constructured for all state-space elements, we can now find the stationary distribution using standard <a href="https://en.wikipedia.org/wiki/Markov_chain#Stationary_distribution_relation_to_eigenvectors_and_simplices">eigenvector</a> approach. See <a href="https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vecsv.html">ff_az_ds_vecsv</a> for additional methods using the full states markov structure.</p><pre class="codeinput"><span class="keyword">if</span> (strcmp(st_analytical_stationary_type, <span class="string">'eigenvector'</span>))
    [V, ~] = eigs(mt_full_trans_mat,1,1);
    ar_stationary = V/sum(V);
<span class="keyword">end</span>
</pre><h2 id="12">G. Stationary Vector to Stationary Matrix in Original Dimensions</h2><pre class="codeinput">mt_dist_akz = reshape(ar_stationary, size(mt_pol_a));
</pre><h2 id="13">End Time and Profiler</h2><pre class="codeinput"><span class="comment">% End Timer</span>
<span class="keyword">if</span> (bl_time)
    toc;
<span class="keyword">end</span>

<span class="comment">% End Profile</span>
<span class="keyword">if</span> (bl_profile_dist)
    profile <span class="string">off</span>
    profile <span class="string">viewer</span>
    st_file_name = [st_profile_prefix st_profile_name_main st_profile_suffix];
    profsave(profile(<span class="string">'info'</span>), strcat(st_profile_path, st_file_name));
<span class="keyword">end</span>
</pre><h2 id="14"><b>f(y), f(c), f(a), f(k)</b>: Generate Key Distributional Statistics for Each outcome</h2><p>Having derived f({a,k},z) the probability mass function of the joint discrete random variables, we now obtain distributional statistics. Note that we know f({a,k},z), and we also know relevant policy functions a'(a,z), c(a,z), or other policy functions. We can simulate any choices that are a function of the random variables (a,z), using f({a,k},z). We call function <a href="https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_ds_post_stats.html">ff_az_ds_post_stats</a> which uses <a href="https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_stats.html">fft_disc_rand_var_stats</a> and <a href="https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_mass2outcomes.html">fft_disc_rand_var_mass2outcomes</a> to compute various statistics of interest.</p><pre class="codeinput">bl_input_override = true;
result_map = ff_az_ds_post_stats(support_map, result_map, mt_dist_akz, bl_input_override);
</pre><pre class="codeoutput">----------------------------------------
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Summary Statistics for: cl_mt_pol_coh
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
----------------------------------------
fl_choice_mean
    6.6968

fl_choice_sd
    3.0965

fl_choice_coefofvar
    0.4624

fl_choice_prob_zero
     0

fl_choice_prob_below_zero
     0

fl_choice_prob_above_zero
    1.0000

fl_choice_prob_max
  -4.2385e-34

tb_prob_drv
    percentiles    cl_mt_pol_cohPercentileValues    fracOfSumHeldBelowThisPercentile
    ___________    _____________________________    ________________________________

        0.1                   2.7491                           0.00065678           
          1                   2.9495                            0.0043457           
          5                   3.3505                             0.030196           
         10                   3.9519                             0.055725           
         15                   4.1524                             0.086451           
         20                   4.4531                              0.14113           
         25                   4.6535                              0.16918           
         35                    5.255                              0.22995           
         50                   5.9566                              0.38108           
         65                   6.8587                              0.50599           
         75                   7.7608                              0.60578           
         80                    8.262                              0.65219           
         85                   9.2644                              0.72335           
         90                   10.668                              0.79519           
         95                   13.174                              0.88529           
         99                   17.985                              0.97001           
       99.9                   24.701                              0.99643           

----------------------------------------
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Summary Statistics for: cl_mt_pol_a
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
----------------------------------------
fl_choice_mean
    0.3082

fl_choice_sd
    1.1367

fl_choice_coefofvar
    3.6883

fl_choice_prob_zero
    0.8819

fl_choice_prob_below_zero
     0

fl_choice_prob_above_zero
    0.1181

fl_choice_prob_max
   6.0168e-34

tb_prob_drv
    percentiles    cl_mt_pol_aPercentileValues    fracOfSumHeldBelowThisPercentile
    ___________    ___________________________    ________________________________

        0.1                       0                                 0             
          1                       0                                 0             
          5                       0                                 0             
         10                       0                                 0             
         15                       0                                 0             
         20                       0                                 0             
         25                       0                                 0             
         35                       0                                 0             
         50                       0                                 0             
         65                       0                                 0             
         75                       0                                 0             
         80                       0                                 0             
         85                       0                                 0             
         90                  1.0204                            0.1151             
         95                  2.0408                           0.33069             
         99                  6.1224                           0.75824             
       99.9                  11.224                           0.96027             

----------------------------------------
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Summary Statistics for: cl_mt_pol_k
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
----------------------------------------
fl_choice_mean
    4.5735

fl_choice_sd
    2.1263

fl_choice_coefofvar
    0.4649

fl_choice_prob_zero
   5.4509e-18

fl_choice_prob_below_zero
     0

fl_choice_prob_above_zero
    1.0000

fl_choice_prob_max
   9.0980e-08

tb_prob_drv
    percentiles    cl_mt_pol_kPercentileValues    fracOfSumHeldBelowThisPercentile
    ___________    ___________________________    ________________________________

        0.1                  2.0408                           0.045564            
          1                  2.0408                           0.045564            
          5                  2.0408                           0.045564            
         10                  2.0408                           0.045564            
         15                  3.0612                            0.21237            
         20                  3.0612                            0.21237            
         25                  3.0612                            0.21237            
         35                  3.0612                            0.21237            
         50                  4.0816                            0.45182            
         65                   5.102                            0.64443            
         75                   5.102                            0.64443            
         80                  6.1224                            0.75776            
         85                  6.1224                            0.75776            
         90                  7.1429                            0.81513            
         95                  9.1837                            0.91772            
         99                  12.245                            0.97392            
       99.9                  16.327                            0.99619            

----------------------------------------
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
Summary Statistics for: cl_mt_pol_c
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
----------------------------------------
fl_choice_mean
    1.8152

fl_choice_sd
    0.5437

fl_choice_coefofvar
    0.2995

fl_choice_prob_zero
     0

fl_choice_prob_below_zero
     0

fl_choice_prob_above_zero
    1.0000

fl_choice_prob_max
  -4.5848e-34

tb_prob_drv
    percentiles    cl_mt_pol_cPercentileValues    fracOfSumHeldBelowThisPercentile
    ___________    ___________________________    ________________________________

        0.1                  0.70825                         0.00062426           
          1                  0.89066                          0.0060645           
          5                   1.0911                           0.042786           
         10                   1.1733                           0.062734           
         15                   1.2736                           0.095819           
         20                   1.3097                            0.13573           
         25                   1.3918                            0.18755           
         35                   1.5382                            0.24577           
         50                   1.7567                            0.39762           
         65                   1.9571                            0.53712           
         75                   2.1757                            0.68536           
         80                   2.2579                            0.72509           
         85                   2.4222                            0.78061           
         90                   2.5405                            0.84159           
         95                   2.8151                            0.91478           
         99                   3.2982                             0.9804           
       99.9                   3.9295                            0.99769           

xxx All Variables PERCENTILES AND STATS xxx
tb_outcomes_meansdperc: mean, sd, percentiles
                      mean        sd      coefofvar      min        max        pYis0       pYls0     pYgr0      pYisMINY      pYisMAXY       p0_1        p1         p5       p10       p15       p20       p25       p35       p50       p65       p75       p80       p85       p90       p95       p99      p99_9 
                     _______    ______    _________    ________    ______    __________    _____    _______    __________    ___________    _______    _______    ______    ______    ______    ______    ______    ______    ______    ______    ______    ______    ______    ______    ______    ______    ______

    cl_mt_pol_coh     6.6968    3.0965     0.46239      0.44365    57.277             0      0            1    5.4509e-18    -4.2385e-34     2.7491     2.9495    3.3505    3.9519    4.1524    4.4531    4.6535     5.255    5.9566    6.8587    7.7608     8.262    9.2644    10.668    13.174    17.985    24.701
    cl_mt_pol_a      0.30818    1.1367      3.6883            0    47.959       0.88187      0      0.11813       0.88187     6.0168e-34          0          0         0         0         0         0         0         0         0         0         0         0         0    1.0204    2.0408    6.1224    11.224
    cl_mt_pol_k       4.5735    2.1263     0.46491            0    22.449    5.4509e-18      0            1    5.4509e-18      9.098e-08     2.0408     2.0408    2.0408    2.0408    3.0612    3.0612    3.0612    3.0612    4.0816     5.102     5.102    6.1224    6.1224    7.1429    9.1837    12.245    16.327
    cl_mt_pol_c       1.8152    0.5437     0.29953     0.024653    7.2772             0      0            1    1.8589e-34    -4.5848e-34    0.70825    0.89066    1.0911    1.1733    1.2736    1.3097    1.3918    1.5382    1.7567    1.9571    2.1757    2.2579    2.4222    2.5405    2.8151    3.2982    3.9295

xxx All Variables Fraction of Y Held up to Percentile xxx
tb_outcomes_fracheld: fraction of asset/income/etc held by hh up to this percentile
                     fracByP0_1    fracByP1     fracByP5    fracByP10    fracByP15    fracByP20    fracByP25    fracByP35    fracByP50    fracByP65    fracByP75    fracByP80    fracByP85    fracByP90    fracByP95    fracByP99    fracByP99_9
                     __________    _________    ________    _________    _________    _________    _________    _________    _________    _________    _________    _________    _________    _________    _________    _________    ___________

    cl_mt_pol_coh    0.00065678    0.0043457    0.030196    0.055725     0.086451      0.14113      0.16918      0.22995      0.38108      0.50599      0.60578      0.65219      0.72335      0.79519      0.88529      0.97001       0.99643  
    cl_mt_pol_a               0            0           0           0            0            0            0            0            0            0            0            0            0       0.1151      0.33069      0.75824       0.96027  
    cl_mt_pol_k        0.045564     0.045564    0.045564    0.045564      0.21237      0.21237      0.21237      0.21237      0.45182      0.64443      0.64443      0.75776      0.75776      0.81513      0.91772      0.97392       0.99619  
    cl_mt_pol_c      0.00062426    0.0060645    0.042786    0.062734     0.095819      0.13573      0.18755      0.24577      0.39762      0.53712      0.68536      0.72509      0.78061      0.84159      0.91478       0.9804       0.99769  

</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><pre class="codeoutput">
ans = 

  Map with properties:

        Count: 14
      KeyType: char
    ValueType: any

</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2019a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Derive Distributions for Risky + Safe Asets + Interpolated Distribution (Analytical)
% *back to <https://fanwangecon.github.io Fan>'s
% <https://fanwangecon.github.io/CodeDynaAsset/ Dynamic Assets Repository>
% Table of Content.*

%%
function [result_map] = ff_iwkz_ds_vecsv(varargin)
%% FF_IWKZ_DS finds the stationary asset distributions
% Building on the Two Assets Two-Step Interpolated Dynamic Programming
% Problem
% <https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_vf_vecsv.html
% ff_iwkz_vf_vecsv>, here we solve for the asset distribution. This version
% of the program is semi-analytical.
%
% This is the two-stage with interpolation version of
% <https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_ds_vecsv.html
% ff_akz_ds_vecsv>. See that file for additional descriptions and
% comparisons. These two functions are nearly identical
%
% The code here works when we are looking for the distribution of f(a,z),
% where a'(a,z,z'), meaning that the a next period is determined by a last
% period and some shock last period as well as shock this period. a here is
% cash-on-hand. This contrasts with
% <https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vecsv.html
% ff_az_ds_vecsv>, which works for a'(a,z), a' can not be a function of z'.
%
% @example
%
%    % Get Default Parameters
%    it_param_set = 6;
%    [param_map, support_map] = ffs_az_set_default_param(it_param_set);
%    % Change Keys in param_map
%    param_map('it_w_n') = 750;
%    param_map('it_ak_n') = param_map('it_w_n');
%    param_map('it_z_n') = 11;
%    param_map('fl_a_max') = 100;
%    param_map('fl_w') = 1.3;
%    % Change Keys support_map
%    support_map('bl_display') = false;
%    support_map('bl_post') = true;
%    support_map('bl_display_final') = false;
%    % Call Program with external parameters that override defaults
%    ff_iwkz_ds_vecsv(param_map, support_map);
%
% @include
%
% * <https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_vf_vecsv.html ff_wkz_vf_vecsv>
% * <https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_ds_post_stats.html ff_az_ds_post_stats>
% * <https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_stats.html fft_disc_rand_var_stats>
% * <https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_mass2outcomes.html fft_disc_rand_var_mass2outcomes>
%
% @seealso
%
% * derive distribution f(y'(y,z)) one asset *loop*: <https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds.html ff_az_ds>
% * derive distribution f(y'({x,y},z)) two assets *loop*: <https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_akz_ds.html ff_akz_ds>
% * derive distribution f(y'({x,y},z, *z'*)) two assets *loop*: <https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_ds.html ff_iwkz_ds>
% * derive distribution f(y'({y},z)) or f(y'({x,y},z)) *vectorized*: <https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vec.html ff_az_ds_vec>
% * derive distribution f(y'({y},z, *z'*)) or f(y'({x,y},z, *z'*)) *vectorized*: <https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_ds_vec.html ff_iwkz_ds_vec>
% * derive distribution f(y'({y},z)) or f(y'({x,y},z)) *semi-analytical*: <https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vecsv.html ff_az_ds_vecsv>
% * derive distribution f(y'({y},z, *z'*)) or f(y'({x,y},z, *z'*)) *semi-analytical*: <https://fanwangecon.github.io/CodeDynaAsset/m_akz/solve/html/ff_iwkz_ds_vecsv.html ff_iwkz_ds_vecsv>
%

%% Default
% Program can be externally invoked with _az_, _abz_ or various other
% programs. By default, program invokes using _az_ model programs:
%
% # it_subset = 5 is basic invoke quick test
% # it_subset = 6 is invoke full test
% # it_subset = 7 is profiling invoke
% # it_subset = 8 is matlab publish
% # it_subset = 9 is invoke operational (only final stats) and coh graph
%

params_len = length(varargin);
bl_input_override = 0;
if (params_len == 6)
    bl_input_override = varargin{6};
end

if (bl_input_override)
    % if invoked from outside override fully
    [param_map, support_map, armt_map, func_map, result_map, ~] = varargin{:};

else
    % default invoke
    close all;

    it_param_set = 8;
    st_akz_or_iwkz = 'iwkz';

    bl_input_override = true;

    % 1. Generate Parameters
    [param_map, support_map] = ffs_akz_set_default_param(it_param_set);

    % Note: param_map and support_map can be adjusted here or outside to override defaults
    % param_map('it_w_n') = 50;
    % param_map('it_z_n') = 15;

    param_map('st_analytical_stationary_type') = 'eigenvector';
    
    % 2. Generate function and grids
    [armt_map, func_map] = ffs_akz_get_funcgrid(param_map, support_map, bl_input_override); % 1 for override

    % 3. Solve value and policy function using ff_iwkz_vf_vecsv
    if (strcmp(st_akz_or_iwkz, 'iwkz'))
        [result_map] = ff_iwkz_vf_vecsv(param_map, support_map, armt_map, func_map);
    end
end

%% Parse Parameters

% append function name
st_func_name = 'ff_iwkz_ds_vecsv';
support_map('st_profile_name_main') = [st_func_name support_map('st_profile_name_main')];
support_map('st_mat_name_main') = [st_func_name support_map('st_mat_name_main')];
support_map('st_img_name_main') = [st_func_name support_map('st_img_name_main')];

% result_map
% ar_st_pol_names is from section _Process Optimal Choices_ in the value
% function code.
params_group = values(result_map, {'cl_mt_pol_a', 'cl_mt_pol_k'});
[cl_mt_pol_a, cl_mt_pol_k] = params_group{:};
[mt_pol_a, mt_pol_k] = deal(cl_mt_pol_a{1}, cl_mt_pol_k{1});

% func_map
params_group = values(func_map, {'f_coh'});
[f_coh] = params_group{:};

% armt_map
params_group = values(armt_map, {'mt_z_trans', 'ar_z'});
[mt_z_trans, ar_z] = params_group{:};
params_group = values(armt_map, {'ar_interp_coh_grid'});
[ar_interp_coh_grid] = params_group{:};

% param_map
params_group = values(param_map, {'it_z_n', 'it_maxiter_dist', 'fl_tol_dist'});
[it_z_n, it_maxiter_dist, fl_tol_dist] = params_group{:};
params_group = values(param_map, { 'it_trans_power_dist', 'st_analytical_stationary_type'});
[it_trans_power_dist, st_analytical_stationary_type] = params_group{:};

% support_map
params_group = values(support_map, {'bl_profile_dist', 'st_profile_path', ...
    'st_profile_prefix', 'st_profile_name_main', 'st_profile_suffix',...
    'bl_time', 'bl_display_dist', 'it_display_every'});
[bl_profile_dist, st_profile_path, ...
    st_profile_prefix, st_profile_name_main, st_profile_suffix, ...
    bl_time, bl_display_dist, it_display_every] = params_group{:};

%% Start Profiler and Timer

% Start Profile
if (bl_profile_dist)
    close all;
    profile off;
    profile on;
end

% Start Timer
if (bl_time)
    tic;
end

%% A. Get Size of Endogenous and Exogenous State

it_endostates_n = length(ar_interp_coh_grid);
it_exostates_n = length(ar_z);

%% B. Solve for Index
% The model is solved by interpolating over cash-on-hand. The optimal
% choices do not map to specific points on the cash-on-hand grid. Find the
% index of the cash-on-hand vector that is the closest to the
% coh'(a'(coh,z),k'(coh,z),z'). 
%
% Since we have *z_n* elements of shocks, and *coh_n* elements of the
% cash-on-hand grid, there are (coh_n x z_n) possible combinations of
% states at period t. In period t+1, there are (coh_n x z_n) by (z_n)
% possible/reachable cash-on-hand points. We find the index of all these
% reachable coh' points on the interpolation cash-on-hand grid.
%

% 1. *mt_coh_prime* is (coh_n x z_n) by (z_n)
% coh'(z', a'(coh,z), k'(coh,z))    
mt_coh_prime = f_coh(ar_z, mt_pol_a(:), mt_pol_k(:));

% 2. *mt_coh_prime_on_grid_idx* is (coh_n x z_n) by (z_n):
% index for coh'(a,k,z')
[~, ar_coh_prime_on_grid_idx] = min(abs(mt_coh_prime(:)' - ar_interp_coh_grid'));
mt_coh_prime_on_grid_idx = reshape(ar_coh_prime_on_grid_idx, size(mt_coh_prime));    

%% C. Expand Index so Matches Full States Index Dimension
% The index above matches the index in the cash-on-hand grid, but now, the
% state space is cash-on-hand jointly with shocks, that is the full states
% markov's states. So if there are two shocks and two cash-on-hand grid
% points, the cash-on-hand grid points would have been [1,2] and [1,2], but
% depending on which z' they match up to, they would now be [1,2] if
% matching to the first z', and [3,4] if matching to the second z'.

% mt_pol_idx_mesh_max is (NxM) by M, mt_pol_idx is N by M
mt_pol_idx_mesh_max = mt_coh_prime_on_grid_idx + (0:1:(it_exostates_n-1))*it_endostates_n;

%% D. Transition Probabilities from (M by M) to (NxM) by M
% Probability comes from the shock transition matrix, which is now
% duplicated for all cash-on-hand grid elements

mt_trans_prob = reshape(repmat(mt_z_trans(:)', ...
    [it_endostates_n, 1]), [it_endostates_n*it_exostates_n, it_exostates_n]);

%% E. Fill mt_pol_idx_mesh_idx to mt_full_trans_mat SPARSE
% Try to always use sparse matrix, unless grid sizes very small, keeping
% non-sparse code here for comparison. Sparse matrix is important for
% allowing the code to be fast and memory efficient. Otherwise this method
% is much slower than iterative method.

i = mt_pol_idx_mesh_max(:);
j = repmat((1:1:it_endostates_n*it_exostates_n),[1,it_exostates_n])';
v = mt_trans_prob(:);
m = it_endostates_n*it_exostates_n;
n = it_endostates_n*it_exostates_n;
mt_full_trans_mat = sparse(i, j, v, m, n);   

%% F. Stationary Distribution *Method A*, Eigenvector Approach
% Given that markov chain we have constructured for all state-space
% elements, we can now find the stationary distribution using standard
% <https://en.wikipedia.org/wiki/Markov_chain#Stationary_distribution_relation_to_eigenvectors_and_simplices
% eigenvector> approach. See
% <https://fanwangecon.github.io/CodeDynaAsset/m_az/solve/html/ff_az_ds_vecsv.html
% ff_az_ds_vecsv> for additional methods using the full states markov
% structure. 

if (strcmp(st_analytical_stationary_type, 'eigenvector'))
    [V, ~] = eigs(mt_full_trans_mat,1,1);
    ar_stationary = V/sum(V);
end

%% G. Stationary Vector to Stationary Matrix in Original Dimensions

mt_dist_akz = reshape(ar_stationary, size(mt_pol_a));


%% End Time and Profiler

% End Timer
if (bl_time)
    toc;
end

% End Profile
if (bl_profile_dist)
    profile off
    profile viewer
    st_file_name = [st_profile_prefix st_profile_name_main st_profile_suffix];
    profsave(profile('info'), strcat(st_profile_path, st_file_name));
end


%% *f(y), f(c), f(a), f(k)*: Generate Key Distributional Statistics for Each outcome
% Having derived f({a,k},z) the probability mass function of the joint discrete
% random variables, we now obtain distributional statistics. Note that we
% know f({a,k},z), and we also know relevant policy functions a'(a,z), c(a,z),
% or other policy functions. We can simulate any choices that are a
% function of the random variables (a,z), using f({a,k},z). We call function
% <https://fanwangecon.github.io/CodeDynaAsset/m_az/solvepost/html/ff_az_ds_post_stats.html
% ff_az_ds_post_stats> which uses
% <https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_stats.html
% fft_disc_rand_var_stats> and
% <https://fanwangecon.github.io/CodeDynaAsset/tools/html/fft_disc_rand_var_mass2outcomes.html
% fft_disc_rand_var_mass2outcomes> to compute various statistics of
% interest.

bl_input_override = true;
result_map = ff_az_ds_post_stats(support_map, result_map, mt_dist_akz, bl_input_override);

end

##### SOURCE END #####
--></body></html>